<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>User space access to hardware</title>
  <style>
    html {
      font-family: monospace;
      font-size: 12pt;
      line-height: 1.25;
      color: #1a1a1a;
      background-color: #F5F5F0;
    }
    body {
      margin: 0 auto;
      max-width: 52em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: #F5F5F0;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: Blue;
    }
    a:visited {
      color: Blue;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      background-color: #E5E5E0;
      padding: .2em .4em;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      background-color: #E5E5E0;
      padding: 1em;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
    span {
        opacity: 1.0;
        #font-size: 12pt;
    }

    img {
      # Border around images;
      padding:            0px;
      border:             2px solid #333;
      #background-color:   #F0F;
      #color:              #000;
      #height:             12em;
      #float:              right;
      #clear:              right;
      #margin-left:        1em;
      #margin-bottom:      1em;
    }

    #     code {
    #       # Style of inline code;
    #       background-color:   #EEE;
    #       font-family:        "Courier New";
    #       font-size: 12pt;
    #       #font-weight: bold;
    #       #border:             2px dashed #E33;
    #       padding:            1px;
    #       border-radius:      0.3em;
    #     }

    #     pre {
    #       # Style of code listings;
    #       background-color:   #EEE;
    #       font-family:        "Courier New";
    #       #font-weight: bold;
    #       border:             1px solid #333;
    #       padding:            3px;
    #       border-radius:      0.3em;
    #     }

    #     figCaption {
    #       display:            block;
    #   }

  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">User space access to hardware</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction"><span
class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#memory-mapping-in-rust"
id="toc-memory-mapping-in-rust"><span
class="toc-section-number">2</span> Memory mapping in Rust</a></li>
<li><a href="#blinking-the-led" id="toc-blinking-the-led"><span
class="toc-section-number">3</span> Blinking the LED</a></li>
<li><a href="#building-the-rust-version"
id="toc-building-the-rust-version"><span
class="toc-section-number">4</span> Building the Rust version</a></li>
<li><a href="#building-the-c-version"
id="toc-building-the-c-version"><span
class="toc-section-number">5</span> Building the C version</a></li>
<li><a href="#pwm-output-via-gpio19"
id="toc-pwm-output-via-gpio19"><span class="toc-section-number">6</span>
PWM output via GPIO19</a>
<ul>
<li><a href="#gpio19-in-pwm-mode" id="toc-gpio19-in-pwm-mode"><span
class="toc-section-number">6.1</span> GPIO19 in PWM mode</a></li>
<li><a href="#clock" id="toc-clock"><span
class="toc-section-number">6.2</span> Clock</a></li>
<li><a href="#pwm" id="toc-pwm"><span
class="toc-section-number">6.3</span> PWM</a></li>
</ul></li>
<li><a href="#synchronization" id="toc-synchronization"><span
class="toc-section-number">7</span> Synchronization</a></li>
<li><a href="#results" id="toc-results"><span
class="toc-section-number">8</span> Results</a></li>
</ul>
</nav>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction</h1>
<p>We will demonstrate how to control GPIO and PWM output from user
space through direct interaction with IO memory.</p>
<p>Registers of hardware peripherals can be accessed by using memory
mappings.</p>
<h1 data-number="2" id="memory-mapping-in-rust"><span
class="header-section-number">2</span> Memory mapping in Rust</h1>
<p>We’ll use the <code>memmap</code> library, and so we add the
following dependency to <code>Cargo.toml</code>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[dependencies]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">memmap</span> <span class="op">=</span> <span class="st">&quot;0.7&quot;</span></span></code></pre></div>
<p>The character device file <code>/dev/mem</code> can be open in
read/write mode as follows:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> path <span class="op">=</span> <span class="dt">Path</span><span class="pp">::</span>new(<span class="st">&quot;/dev/mem&quot;</span>)<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> file <span class="op">=</span> <span class="pp">fs::OpenOptions::</span>new()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>read(<span class="cn">true</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>write(<span class="cn">true</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>open(<span class="op">&amp;</span>path)<span class="op">?;</span></span></code></pre></div>
<p>Then, the section of <code>/dev/mem</code> of length
<code>BCM2835_PERIPH_SIZE=0x01000000</code> beginning at offset
<code>BCM2835_PERIPH_BASE=0x20000000</code> is mapped to a memory region
starting at the virtual base address <code>vaddr</code>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mmap<span class="op">:</span> MmapMut <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">MmapOptions::</span>new()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>offset(<span class="pp">constants::</span>BCM2835_PERIPH_BASE <span class="kw">as</span> <span class="dt">u64</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>len(<span class="pp">constants::</span>BCM2835_PERIPH_SIZE)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>map_mut(<span class="op">&amp;</span>file)<span class="op">?;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vaddr <span class="op">=</span> mmap<span class="op">.</span>as_ptr() <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u32</span><span class="op">;</span></span></code></pre></div>
<p>Here, we use the <code>map_mut</code> method such that the memory
region is mutable.</p>
<p>Our memory allocation in Rust is equivalent to calling
<code>mmap</code> from a C program with</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Peripherals base addr on BCM2835 */</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BCM2835_PERIPH_BASE             </span><span class="bn">0x20000000</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* Peripherals size*/</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BCM2835_PERIPH_SIZE             </span><span class="bn">0x01000000</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fd <span class="op">=</span> open<span class="op">(</span><span class="st">&quot;/dev/mem&quot;</span><span class="op">,</span> O_RDWR<span class="op">);</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>mmap<span class="op">(</span><span class="dv">0</span><span class="op">,</span> BCM2835_PERIPH_SIZE<span class="op">,</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        PROT_READ <span class="op">|</span> PROT_WRITE<span class="op">,</span> MAP_SHARED<span class="op">,</span> fd<span class="op">,</span> BCM2835_PERIPH_BASE<span class="op">)</span></span></code></pre></div>
<p>i.e. memory mapping into <code>/dev/mem</code> the whole 16MB IO
peripherals memory region in RW mode and with the MAP_SHARED flag
set.</p>
<p>In the next section we will implement a program that blinks LEDs
until CTRL+C is pressed. Running <code>strace</code> on that program and
redirecting the output to <code>out.txt</code> will show us some
interesting information. Our LED program notifies us that the physical
peripheral memory region was mapped at virtual address
<code>0xb5dbf000</code>.</p>
<pre class="plain"><code># strace ./rustmem leds 2&gt;out.txt
mmap.as_ptr = 0xb5dbf000
Press CTRL+C to exit.
^C</code></pre>
<p>Looking at the <code>strace</code> output we can deduce which system
calls were used behind the scene when we allocated memory in the Rust
program above.</p>
<pre class="plain"><code># cat out.txt 
...
openat(AT_FDCWD, &quot;/dev/mem&quot;, O_RDWR|O_LARGEFILE|O_CLOEXEC) = 3
mmap2(NULL, 16777216, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0x20000000) = 0xb5dbf000
...</code></pre>
<p>The glibc function <code>mmap</code> is a wrapper for the system call
<code>mmap2</code>. We conclude that the C program and its Rust
couterpart do actually the same things when allocating virtual memory
that maps the physical memory region. Rust’s <code>memmap</code> adds
the extra flags O_LARGEFILE and O_CLOEXEC.</p>
<p>The O_CLOEXEC flag should not be needed here since we don’t need to
share the <code>/dev/mem</code> file descriptor with a child
process.</p>
<p>We note that O_LARGEFILE is needed when opening a file whose size
cannot be represented in an <code>off_t</code>. Collecting information
trough the Linux sources of our RPI image, we see that an
<code>off_t</code> is the same as an (unsigned) <code>long</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> __kernel_off_t   off_t<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> __kernel_long_t  __kernel_off_t</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span>             __kernel_long_t</span></code></pre></div>
<p>A <code>long</code> is at most 2G on a 32-bit Raspberry according to
<a
href="https://raspberry-projects.com/pi/programming-in-c/memory/variables">this</a>.
So assuming the <code>/dev/mem</code> is 512MB, we actually would
<em>not</em> need the O_LARGEFILE flag either.</p>
<h1 data-number="3" id="blinking-the-led"><span
class="header-section-number">3</span> Blinking the LED</h1>
<p>LED0 on GPIO26 can be turned on and off by directly writing to GPIO
registers. The registers of interest here are GPFSEL, GPSET, and GPCLR
described in the <a
href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">BCM2825
Manual</a> in Chapter 6.</p>
<p>The relevant part of the GPIO registers in the BCM2835 Manual is
shown in Figure 1.</p>
<figure id="fig:gpio_registers">
<img src="images/gpio_registers.png" style="width:100.0%"
alt="Figure 1: GPIO registers." />
<figcaption aria-hidden="true">Figure 1: GPIO registers.</figcaption>
</figure>
<p>First we need to determine the beginning of GPIO memory, so we define
<code>GPIO_OFFSET=0x00200000</code> and the beginning of the GPIO memory
is computed as</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gpio_base_ptr <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> base<span class="op">.</span>add(GPIO_OFFSET <span class="op">&gt;&gt;</span> <span class="dv">2</span>) <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u32</span> <span class="op">};</span></span></code></pre></div>
<p>The <code>GPIO_OFFSET</code> is divided by 4
(<code>&gt;&gt; 2</code>) before adding it to the peripheral base
address since we are doing 32-bit pointer arithmetics.</p>
<p>The GPFSELn registers each determine the functionality of 10
successive GPIO pins (GPFSEL5 only determine the functionality of pin 50
to 53 though). The functionality of pin number <code>pin_nr</code> can
be set in GPFSELn, where <code>n = pin_nr/10</code>, by manipulating the
3-bit pattern ranging from position <code>m</code> to <code>m+2</code>
where <code>m = 3(pin_nr % 10)</code>.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> pin_nr <span class="op">/</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gpfsel_addr<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u32</span> <span class="op">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span> <span class="kw">self</span><span class="op">.</span>gpio_base_ptr<span class="op">.</span>add(GPFSEL0)<span class="op">.</span>add(n) <span class="op">};</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pattern <span class="op">=</span> [<span class="pp">bits::</span>BitPattern <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    value<span class="op">:</span> mode<span class="op">,</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    start<span class="op">:</span> ((pin_nr <span class="op">%</span> <span class="dv">10</span>) <span class="op">*</span> FSEL_PATTERN_SIZE) <span class="kw">as</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    size<span class="op">:</span> FSEL_PATTERN_SIZE <span class="kw">as</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>]<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>set_bit_pattern(gpfsel_addr<span class="op">,</span> <span class="op">&amp;</span>pattern)<span class="op">.</span>map_err(<span class="bu">Error</span><span class="pp">::</span>SetGpFsel)</span></code></pre></div>
<p>The <code>unsafe</code> statement calculates the address
<code>gpfsel_addr</code> of the register in which the functionality of
GPIO26 can be specified. We have <code>n=2</code> and
<code>GPFSEL0=0</code>, since GPFSEL0 is the first register in GPIO
memory, and so</p>
<pre class="plain"><code>gpfsel_addr = gpio_base_ptr + (GPFSEL0 * 4) + (n * 4)
            = 0x20200000 + 0 + 8 
            = 0x20200008</code></pre>
<p>which is indeed the address of GPFSEL2 according to Figure 1.</p>
<p>Figure 2 shows the GPIO Function Select register GPFSEL2. In order to
set GPIO26 in output mode (<code>0b001</code>), we need to set bit 18-20
in GPFSEL (counting from 0) to the bit pattern
<code>mode=0b001</code>.</p>
<figure id="fig:gpio_alt_20_29">
<img src="images/gpio_alt_20_29.png" style="width:100.0%"
alt="Figure 2: GPIO alternate function selection in register GPFSEL2." />
<figcaption aria-hidden="true">Figure 2: GPIO alternate function
selection in register GPFSEL2.</figcaption>
</figure>
<p>The <code>set_bit_pattern</code> which sets a bit pattern within a
register is defined below</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> set_bit_pattern(addr<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u32</span><span class="op">,</span> patterns<span class="op">:</span> <span class="op">&amp;</span>[BitPattern]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> word<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> addr<span class="op">.</span>read_volatile() <span class="op">};</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> patterns<span class="op">.</span>into_iter() <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> end<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> p</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>start</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>checked_add(p<span class="op">.</span>size)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>ok_or(<span class="pp">BitError::</span>BitPatternIntegerOverflow)<span class="op">?;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> left_shift<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> (<span class="dv">32</span> <span class="kw">as</span> <span class="dt">u8</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>checked_sub(p<span class="op">.</span>size)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>ok_or(<span class="pp">BitError::</span>BitPatternTooLong)<span class="op">?;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> right_shift<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> (<span class="dv">32</span> <span class="kw">as</span> <span class="dt">u8</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>checked_sub(end)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>ok_or(<span class="pp">BitError::</span>BitPatternDoesNotFitIn)<span class="op">?;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> mask<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> ((<span class="op">!</span><span class="dv">0</span> <span class="kw">as</span> <span class="dt">u32</span>) <span class="op">&lt;&lt;</span> left_shift) <span class="op">&gt;&gt;</span> right_shift<span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        word <span class="op">&amp;=</span> <span class="op">!</span>mask<span class="op">;</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        word <span class="op">|=</span> p<span class="op">.</span>value <span class="op">&lt;&lt;</span> p<span class="op">.</span>start<span class="op">;</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        addr<span class="op">.</span>write_volatile(word)<span class="op">;</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here, we start by reading the 32-bit value <code>word</code> at
<code>addr</code>. A <code>pattern</code> consists of a
<code>start</code> bit, a <code>size</code>, and a <code>value</code>
that will be written from bit <code>start</code> to bit
<code>start+size-1</code>. We create the <code>mask</code> while
checking that it fits within the boundaries of a 32-bit register, then
apply it to the read <code>word</code>, and finally write the
<code>value</code> into <code>word</code> at the correct bit position.
When all patterns have been applied, we write the altered
<code>word</code> back to the <code>addr</code>.</p>
<p>We use <code>volatile</code> read and writes. We are reading and
writing the same address such that read/write reorderings caused by
compiler optimizations within <code>set_bit_pattern()</code> should not
occur. Nevertheless, we do not want the read and write instructions to
be reordered with read and write instructions to other GPIO registers,
in particular GPSETn and GPCLRn below, so we still want to use
<code>volatile</code>.</p>
<p>Now that we have set GPIO26 in output mode, we are ready to turn LED0
on and off. The bits of GPSETn can be used to set each of the 54 GPIO
pins. The GPIO Output Set Registers, GPSET0 and GPSET1, are shown in
c.f. Figure 3 and Figure 4 below.</p>
<figure id="fig:gpset0">
<img src="images/gpset0.png" style="width:100.0%"
alt="Figure 3: GPIO Output Set Register 0." />
<figcaption aria-hidden="true">Figure 3: GPIO Output Set Register
0.</figcaption>
</figure>
<figure id="fig:gpset1">
<img src="images/gpset1.png" style="width:100.0%"
alt="Figure 4: GPIO Output Set Register 0." />
<figcaption aria-hidden="true">Figure 4: GPIO Output Set Register
0.</figcaption>
</figure>
<p>Then, GPIO <code>pin_nr</code> can be set by setting bit number
<code>pin_nr % 32</code> in GPSETn, where <code>n=pin_nr/32</code>.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n <span class="op">=</span> pin <span class="op">/</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gpset_addr<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u32</span> <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="kw">self</span><span class="op">.</span>gpio_base_ptr<span class="op">.</span>add(GPSET0 <span class="op">+</span> n) <span class="op">};</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> off <span class="op">=</span> pin <span class="op">%</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="op">{</span> gpset_addr<span class="op">.</span>write_volatile(<span class="dv">1</span> <span class="op">&lt;&lt;</span> off) <span class="op">};</span></span></code></pre></div>
<p>The index of the GPSET0 register is <code>GPSET0=7</code> and so its
address can be calculated explicitly as</p>
<pre class="plain"><code>gpset_addr = gpio_base_ptr + (GPSET0 * 4) + (n * 4)
            = 0x20200000 + 0x1c + 0
            = 0x2020001c</code></pre>
<p>which is indeed the address of GPSET0 according to Figure 1.</p>
<p>Similarly, each of the 54 GPIO pins can be cleared by setting a bit
in either GPCLR0 or GPCLR1, c.f. Figure 5 and Figure 6. LED0 can be
turned off by setting bit nr. 26 of PCLR0. Since GPCLR0 is the 10’th
32-bit GPIO register the bit needs to be set in the 32-bit word at
address <code>gpclr_addr = gpio_base_ptr + 10 * 4 = 0x20200028</code>,
in accordance with Figure 1.</p>
<figure id="fig:gpclr0">
<img src="images/gpclr0.png" style="width:100.0%"
alt="Figure 5: GPIO Output Clear Register 0." />
<figcaption aria-hidden="true">Figure 5: GPIO Output Clear Register
0.</figcaption>
</figure>
<figure id="fig:gpclr1">
<img src="images/gpclr1.png" style="width:100.0%"
alt="Figure 6: GPIO Output Clear Register 1." />
<figcaption aria-hidden="true">Figure 6: GPIO Output Clear Register
1.</figcaption>
</figure>
<p>A demonstration of a program blinking all three leds in a nice
pattern is shown below.</p>
<figure id="fig:irl_leds">
<img src="images/irl_leds.gif" width="400"
alt="Figure 7: Blinking leds" />
<figcaption aria-hidden="true">Figure 7: Blinking leds</figcaption>
</figure>
<h1 data-number="4" id="building-the-rust-version"><span
class="header-section-number">4</span> Building the Rust version</h1>
<p>To configure the cross-compiler, we add a
<code>.cargo/config.toml</code> configuration for the
<code>arm-unknown-linux-gnueabihf</code> target.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[target.arm-unknown-linux-gnueabihf]</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">linker</span> <span class="op">=</span> <span class="st">&quot;arm-poky-linux-gnueabi-gcc&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">rustflags</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;-C&quot;</span><span class="op">,</span> <span class="st">&quot;link-arg=-march=armv6&quot;</span><span class="op">,</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;-C&quot;</span><span class="op">,</span> <span class="st">&quot;link-arg=-mfpu=vfp&quot;</span><span class="op">,</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;-C&quot;</span><span class="op">,</span> <span class="st">&quot;link-arg=-mfloat-abi=hard&quot;</span><span class="op">,</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;-C&quot;</span><span class="op">,</span> <span class="st">&quot;link-arg=-mtune=arm1176jzf-s&quot;</span><span class="op">,</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;-C&quot;</span><span class="op">,</span> <span class="st">&quot;link-arg=--sysroot=/opt/poky/3.1.4/sysroots/arm1176jzfshf-vfp-poky-linux-gnueabi&quot;</span><span class="op">,</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="op">]</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="kw">[profile.release]</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="dt">strip</span> <span class="op">=</span> <span class="cn">true</span>        <span class="co"># Strip symbols and debuginfo from the binary.</span></span></code></pre></div>
<p>The following compiler flags are used:</p>
<ul>
<li><code>"link-arg=-march=armv6"</code>. The target ARM architecture.
The PI Zero is based on the ARMv6 architecture.</li>
<li><code>"link-arg=-mfpu=vfp"</code>. The floating point hardware
available on the target. VFP means Vector Floating Point unit.</li>
<li><code>"link-arg=-mfloat-abi=hard"</code>. Which floating-point ABI
to use. <code>hard</code> allows generation of floating-point
instructions and uses FPU-specific calling conventions.</li>
<li><code>"link-arg=-mtune=arm1176jzf-s"</code>. Optimization of the
generated code. The BCM2835 SOC has a ARM1176JZF-S single core
processor.</li>
<li><code>"link-arg=--sysroot=/opt/poky/3.1.4/sysroots/arm1176jzfshf-vfp-poky-linux-gnueabi"</code>.
Directory to use as the logical root directory for headers
(<code>&lt;dir&gt;/usr/include</code>) and libraries
(<code>&lt;dir&gt;/usr/lib</code>).</li>
</ul>
<p>For documentation see also the <a
href="https://developer.arm.com/documentation/ddi0301/h/introduction/about-the-processor">ARM1176JZF-S
Technical Reference Manual</a>.</p>
<p>Finally, we use <code>strip=true</code> for the <code>release</code>
profile in order to strip symbols and debuginfo from the ELF and
dramatically reduce the size of the binary that is uploaded to the
RPI0.</p>
<p>The binary is built in release mode, targetting
<code>arm-unknown-linux-gnueabihf</code>.</p>
<pre class="plain"><code>$ cargo build --target arm-unknown-linux-gnueabihf --release
    Finished release [optimized] target(s) in 0.01s</code></pre>
<h1 data-number="5" id="building-the-c-version"><span
class="header-section-number">5</span> Building the C version</h1>
<p>The flags used in the linker invocation above are identical to the
flags passed to the <code>gcc</code> compiler when cross-compiling the C
version of the program:</p>
<pre class="plain"><code>arm-poky-linux-gnueabi-gcc  \
    -march=armv6 \
    -mfpu=vfp \
    -mfloat-abi=hard \
    -mtune=arm1176jzf-s \
    --sysroot=$SDKTARGETSYSROOT </code></pre>
<p>with</p>
<pre class="plain"><code>$ echo $SDKTARGETSYSROOT 
/opt/poky/3.1.4/sysroots/arm1176jzfshf-vfp-poky-linux-gnueabi</code></pre>
<h1 data-number="6" id="pwm-output-via-gpio19"><span
class="header-section-number">6</span> PWM output via GPIO19</h1>
<h2 data-number="6.1" id="gpio19-in-pwm-mode"><span
class="header-section-number">6.1</span> GPIO19 in PWM mode</h2>
<p>As we saw in the LED program above the alternate function for GPIO19
can be set by writing the appropriate bit pattern to a GPFSELn register.
For <code>pin_nr=19</code>, we have <code>n/10=1</code> and
<code>3(n%10)=27</code>, so we need to write the bit pattern at bit
27-29 of GPFSEL1. A partial view of the GPIO Alternate function select
register 1 from the BCM2835 manual is shown in Figure 8.</p>
<figure id="fig:gpfsel1">
<img src="images/gpfsel1.png" style="width:100.0%"
alt="Figure 8: GPIO Alternate function select register 1." />
<figcaption aria-hidden="true">Figure 8: GPIO Alternate function select
register 1.</figcaption>
</figure>
<p>Furthermore, we see from a collapsed view of the Alternative Function
Assignments in section 6.2 of the BCM2835 manual, c.f. Figure 9, that
the PWM1 corresponds to the alternate function 5, and Figure 8 tells us
that the corresponding pattern to be written in GPFSEL1 is
<code>0b010</code>.</p>
<figure id="fig:gpio19_alt_fcn">
<img src="images/gpio19_alt_fcn.png" style="width:100.0%"
alt="Figure 9: Alternative function assignments for GPIO19." />
<figcaption aria-hidden="true">Figure 9: Alternative function
assignments for GPIO19.</figcaption>
</figure>
<h2 data-number="6.2" id="clock"><span
class="header-section-number">6.2</span> Clock</h2>
<p>We now need to configure the clock. The following Clock Management
Registers are interesting for PWM.</p>
<table>
<thead>
<tr>
<th>Address</th>
<th>Field Name</th>
<th>Description</th>
<th>Size</th>
<th>Read/Write</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x7e1010a0</td>
<td>CM_PWM_CTL</td>
<td>Clock Control</td>
<td>32</td>
<td>R/W</td>
</tr>
<tr>
<td>0x7e1010a4</td>
<td>CM_PWM_DIV</td>
<td>Clock Divisor</td>
<td>32</td>
<td>R/W</td>
</tr>
</tbody>
</table>
<p>From the table above we deduce that the offset address for the CM
registers, computed relatively to the IO peripheral <code>base</code>,
is <code>CLOCK_MANAGEMENT_OFFSET=0x00101000</code>, and we define the
offsets of the two registers above as
<code>CM_PWM_CTL_OFFSET=0xa0</code> and
<code>CM_PWM_DIV_OFFSET = 0xa4</code>.</p>
<p>We set CM base address <code>clock_base_ptr</code> to be</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> clock_base_ptr <span class="op">=</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span> base<span class="op">.</span>add(CLOCK_MANAGEMENT_OFFSET <span class="op">&gt;&gt;</span> <span class="dv">2</span>) <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u32</span> <span class="op">};</span></span></code></pre></div>
<p>Then, the address of the PWM_CTL and PWM_DIV registers can be set
to</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cm_pwm_div <span class="op">=</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span> <span class="kw">self</span><span class="op">.</span>clock_base_ptr<span class="op">.</span>add(CM_PWM_DIV_OFFSET <span class="op">&gt;&gt;</span> <span class="dv">2</span>) <span class="op">};</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cm_pwm_ctl <span class="op">=</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span> <span class="kw">self</span><span class="op">.</span>clock_base_ptr<span class="op">.</span>add(CM_PWM_CTL_OFFSET <span class="op">&gt;&gt;</span> <span class="dv">2</span>) <span class="op">};</span></span></code></pre></div>
<p>Now from the <a
href="https://www.scribd.com/doc/127599939/BCM2835-Audio-clocks">BCM2835
Audio Clocks</a> documentation we can extract Figure 10.</p>
<figure id="fig:pwm_clock_control">
<img src="images/pwm_clock_control.png" style="width:100.0%"
alt="Figure 10: PWM Control clock" />
<figcaption aria-hidden="true">Figure 10: PWM Control clock</figcaption>
</figure>
<p>In the clock control register PWM_CTL we want to enable the clock
(ENB=1), and set the source to be an external oscillator (SRC=OSC). We
also need to remember the password (PASSWORD=0x5a). In other terms, we
want to write <code>src=0x1</code> in the 4-bit slice at bit-offset 0,
<code>src=0x1</code> in the 1-bit slice at bit-offset 4, and
<code>0x5a</code> in the 8-bit slice at bit-offset 24:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ctl_patterns <span class="op">=</span> [</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// PASSWD = cm_pwm_ctl[24..31] = 0x5A</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    BitPattern <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> <span class="dv">0x5A</span><span class="op">,</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        start<span class="op">:</span> <span class="dv">24</span><span class="op">,</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        size<span class="op">:</span> <span class="dv">8</span><span class="op">,</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ENB = cmp_pwm_ctl[4] = 1 (enable)</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    BitPattern <span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> enb<span class="op">,</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        start<span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        size<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// SRC = cmp_pwm_ctl[0..3] = 1 (external oscillator)</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    BitPattern <span class="op">{</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> src<span class="op">,</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        start<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>        size<span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>set_bit_pattern(cm_pwm_ctl<span class="op">,</span> <span class="op">&amp;</span>ctl_patterns)</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>map_err(<span class="bu">Error</span><span class="pp">::</span>SetPwmClockControlRegister)<span class="op">?;</span></span></code></pre></div>
<p>Note that our <code>set_bit_pattern()</code> function will also
preserve the value of the readable bits that we do not alter in the
PWD_CTL register.</p>
<p>Next, we want to set the Clock divider DIVI to a power of 2, e.g. 16,
c.f. Figure 11.</p>
<figure id="fig:pwm_clock_divisor">
<img src="images/pwm_clock_divisor.png" style="width:100.0%"
alt="Figure 11: PWM Control clock" />
<figcaption aria-hidden="true">Figure 11: PWM Control clock</figcaption>
</figure>
<p>Following the same reasoning as for the CTL register we conclude that
the relevant bits of the DIV register can be set as follows:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> div_patterns <span class="op">=</span> [</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// PASSWD = cmp_pwm_div[12..23] = 0x5A</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    BitPattern <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> <span class="dv">0x5A</span><span class="op">,</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        start<span class="op">:</span> <span class="dv">24</span><span class="op">,</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        size<span class="op">:</span> <span class="dv">8</span><span class="op">,</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// DIVI = cmp_pwm_div[12..23] = 16</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    BitPattern <span class="op">{</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> divi<span class="op">,</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        start<span class="op">:</span> <span class="dv">12</span><span class="op">,</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        size<span class="op">:</span> <span class="dv">12</span><span class="op">,</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>set_bit_pattern(cm_pwm_div<span class="op">,</span> <span class="op">&amp;</span>div_patterns)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>map_err(<span class="bu">Error</span><span class="pp">::</span>SetPwmClockDivisorRegister)<span class="op">?;</span></span></code></pre></div>
<p>The DIVI and DIVF registers are used to set the PWM clock speed. We
refer here to Section 6.3 of the BCM manual, <em>General Purpose GPIO
Clocks</em>. The output frequency is computed using the (approximate)
formula:</p>
<pre class="plain"><code>pwm_clk = source_frequency / (DIVI + DIVF/1024)</code></pre>
<p>In fact the value of DIVF is ignored here since the MASH-bit in CTL
is by default unset, meaning that the <code>pwm_clk</code> is computed
using an integer division, so approximately,</p>
<pre class="plain"><code>pwm_clk = source_frequency / DIVI</code></pre>
<p>Assuming <code>source_frequency=19.2MHz</code> and
<code>DIVI=16</code>, we get <code>pwm_clk=1.2MHz</code>. The clock
source frequency is given by the control register.</p>
<h2 data-number="6.3" id="pwm"><span
class="header-section-number">6.3</span> PWM</h2>
<p>The PWM Address Map found in Section 9.6 of the BCM2835 manual is
shown in Figure 12.</p>
<figure id="fig:pwm_addr_map">
<img src="images/pwm_addr_map.png" style="width:100.0%"
alt="Figure 12: PWM Control clock" />
<figcaption aria-hidden="true">Figure 12: PWM Control clock</figcaption>
</figure>
<p>The three registers of interest are CTL, RNG2, and DAT2, at offset
0x0, 0x20, amd 0x24, respectively, from the base address 0x0x0020c000,
<a
href="https://github.com/hermanhermitage/videocoreiv/wiki/Register-Documentation">Register
Documentation</a>.</p>
<p>From the BCM2835 Manual we collect the following information:</p>
<ul>
<li>RNG2: <em>This register is used to define the range for the
corresponding channel. In PWM mode evenly distributed pulses are sent
within a period of length defined by this register.</em></li>
<li>DAT2: <em>…the value of this register defines the number of pulses
which is sent within the period defined by RNG2.</em></li>
</ul>
<p>The RNG2 register can be set 1024, and DAT2 can be set to a user
given value between 0 and 1024, 500 say, as follows.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pwm_rng2_ptr <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>pwm_base_ptr<span class="op">.</span>add(<span class="dv">0x20</span> <span class="op">&gt;&gt;</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    pwm_rng2_ptr<span class="op">.</span>write_volatile(rng2)<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pwm_rng2_ptr <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>pwm_base_ptr<span class="op">.</span>add(<span class="dv">0x24</span> <span class="op">&gt;&gt;</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    pwm_rng2_ptr<span class="op">.</span>write_volatile(dat2)<span class="op">;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>We then get the following period</p>
<pre class="plain"><code>period = RNG2 / pwm_clk = 1024 / 1.2MHz = 853.3 us</code></pre>
<p>i.e. which is <code>~1172 Hz</code>.</p>
<p>For the CTL register the two fields below are of interest:</p>
<p><img src="images/msen2.png" id="fig:msen2" style="width:100.0%"
alt="MSEN2" /> <img src="images/pwen2.png" id="fig:pwen2"
style="width:100.0%" alt="PWEN2" /></p>
<p>We enable Channel 2 and set it up to use the PWM algorithm by
manipulating the CTL register, more precisely by setting the MSEN2 bit
15 to 0x0 and the PWEN2 bit 8 to 0x1 (<em>typo: Channel 1 Enable –&gt;
Channel 2 Enable</em>).</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ctl_patterns <span class="op">=</span> [</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// MSEN2 = CTL[15] = 0 (PWM algo)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">bits::</span>BitPattern <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> msen2<span class="op">,</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        start<span class="op">:</span> <span class="dv">15</span><span class="op">,</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        size<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// PWEN2 = CTL[8] = 1 (enabled)</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">bits::</span>BitPattern <span class="op">{</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> pwen2<span class="op">,</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        start<span class="op">:</span> <span class="dv">8</span><span class="op">,</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        size<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>set_bit_pattern(<span class="kw">self</span><span class="op">.</span>pwm_base_ptr<span class="op">,</span> <span class="op">&amp;</span>ctl_patterns)</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>map_err(<span class="bu">Error</span><span class="pp">::</span>SetMsen2AndPwen2FieldsOfCtlRegister)</span></code></pre></div>
<p>The bit pattern is written at the Pulse Width Modulator PWM0 base
address since the offset of the CTL register is 0x0.</p>
<h1 data-number="7" id="synchronization"><span
class="header-section-number">7</span> Synchronization</h1>
<p>According to Section 1.3 in the BCM2835 manual, <em>Peripheral access
precautions for correct memory ordering</em>, one should place memory
barriers before the first write and after the last read to a peripheral.
We are using three different peripherals, GPIO, Clock Management, and
PWM. In Rust, we can insert a <em>full</em> barrier, which is stronger
than memory <em>read</em> and memory <em>write</em> barriers, with
<code>fence(Ordering::SeqCst)</code>. To be on the safe size, the
initialization of PWM output via GPIO19 can be carried out as
follows</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    fence(<span class="pp">Ordering::</span>SeqCst)<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    gpio19_setup(<span class="op">&amp;</span>mmap)<span class="op">?;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    fence(<span class="pp">Ordering::</span>SeqCst)<span class="op">;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    clock_management_setup(<span class="op">&amp;</span>mmap<span class="op">,</span> <span class="op">&amp;</span>ctx<span class="op">.</span>clock_regs)<span class="op">?;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    fence(<span class="pp">Ordering::</span>SeqCst)<span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    pwm_setup(<span class="op">&amp;</span>mmap<span class="op">,</span> <span class="op">&amp;</span>ctx<span class="op">.</span>pwm_regs)<span class="op">?;</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    fence(<span class="pp">Ordering::</span>SeqCst)<span class="op">;</span></span></code></pre></div>
<h1 data-number="8" id="results"><span
class="header-section-number">8</span> Results</h1>
<p>We measure the PWM clock period by setting DAT2=1. In Figure 13 we
see that the measured PWM period corresponds to the one calculated above
<code>~853 us</code>.</p>
<figure id="fig:digi_clock_div16">
<img src="images/digi_clock_div16.png" style="width:100.0%"
alt="Figure 13: digi_clock_div16" />
<figcaption aria-hidden="true">Figure 13: digi_clock_div16</figcaption>
</figure>
<p>Using DIVI=32 instead of 16, the pediod is doubled as expected since
we compute <code>period = 1706.6 us</code> which is in accordance with
the measurement in Figure 14.</p>
<figure id="fig:digi_clock_div32">
<img src="images/digi_clock_div32.png" style="width:100.0%"
alt="Figure 14: digi_clock_div32" />
<figcaption aria-hidden="true">Figure 14: digi_clock_div32</figcaption>
</figure>
<p>If we again set DIVI-16 but this time set the level DAT2=512, we
expect a period of about <code>853.3 us / 512 ~ 1.666 us</code>, which
is in fact the period we measured, c.f. Figure 15.</p>
<figure id="fig:digi_clock_div16_dat500">
<img src="images/digi_clock_div16_dat500.png" style="width:100.0%"
alt="Figure 15: digi_clock_div32" />
<figcaption aria-hidden="true">Figure 15: digi_clock_div32</figcaption>
</figure>
</body>
</html>
