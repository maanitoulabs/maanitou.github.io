<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The kernel interface</title>
  <style>
    html {
      font-family: monospace;
      font-size: 12pt;
      line-height: 1.25;
      color: #1a1a1a;
      background-color: #F5F5F0;
    }
    body {
      margin: 0 auto;
      max-width: 52em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: #F5F5F0;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: Blue;
    }
    a:visited {
      color: Blue;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      background-color: #E5E5E0;
      padding: .2em .4em;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      background-color: #E5E5E0;
      padding: 1em;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">The kernel interface</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction"><span
class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#accessing-hardware-resources-from-the-shell"
id="toc-accessing-hardware-resources-from-the-shell"><span
class="toc-section-number">2</span> Accessing hardware resources from
the shell</a>
<ul>
<li><a href="#pushing-the-buttons" id="toc-pushing-the-buttons"><span
class="toc-section-number">2.1</span> Pushing the buttons</a></li>
<li><a href="#turning-the-leds-on-and-off-on-the-rpi"
id="toc-turning-the-leds-on-and-off-on-the-rpi"><span
class="toc-section-number">2.2</span> Turning the LEDs on and off on the
RPi</a></li>
</ul></li>
<li><a href="#accessing-hardware-devices-from-a-c-program"
id="toc-accessing-hardware-devices-from-a-c-program"><span
class="toc-section-number">3</span> Accessing hardware devices from a C
program</a></li>
<li><a href="#file-operations-to-i2c-devices"
id="toc-file-operations-to-i2c-devices"><span
class="toc-section-number">4</span> File operations to I2C
devices</a></li>
<li><a
href="#accessing-temperature-measurements-from-the-rpis-http-server"
id="toc-accessing-temperature-measurements-from-the-rpis-http-server"><span
class="toc-section-number">5</span> Accessing temperature measurements
from the RPi’s HTTP server</a></li>
</ul>
</nav>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction</h1>
<p>The goal of this exercise is to demonstrate how to access hardware
resources through the file system, i.e. without having to write a device
driver.</p>
<h1 data-number="2"
id="accessing-hardware-resources-from-the-shell"><span
class="header-section-number">2</span> Accessing hardware resources from
the shell</h1>
<p>The techniques used in this section are described in the kernel
documentation: <a
href="https://www.kernel.org/doc/html/v5.4/driver-api/gpio/legacy.html#sysfs-interface-for-userspace-optional">Sysfs
Interface for Userspace</a>.</p>
<p>Figure 1 shows how LEDs and buttons (BTNs) are connected via the pin
header (2x20 pins) to the GPIO pins of the RPi board.</p>
<figure id="fig:ase_fhat_rpi_interface">
<img src="images/ase_fhat_rpi_interface.png" style="width:80.0%"
alt="Figure 1: RPi interface" />
<figcaption aria-hidden="true">Figure 1: RPi interface</figcaption>
</figure>
<h2 data-number="2.1" id="pushing-the-buttons"><span
class="header-section-number">2.1</span> Pushing the buttons</h2>
<p>The GPIO port numbers corresponding to push-button SW1 and SW2 can be
inferred by comparing the RPi interface in figure 1 with the circuit
diagram of the two push-buttons shown in figure 2.</p>
<figure id="fig:buttons">
<img src="images/buttons.png" style="width:50.0%"
alt="Figure 2: Buttons on the ASE fHAT board." />
<figcaption aria-hidden="true">Figure 2: Buttons on the ASE fHAT
board.</figcaption>
</figure>
<p>We see that SW1 is connected via BTN0 to pin 32 which corresponds to
GPIO12. Similarly, SW2 corresponds to GPIO16. Let us pick push-button
SW1 on GPIO12.</p>
<p>The (deprecated) GPIO interface can be used to get control over the
GPIO from userspace. First, we will write the chosen GPIO number to
<code>/sys/class/gpio/export</code>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> 12 <span class="op">&gt;</span> /sys/class/gpio/export</span></code></pre></div>
<p>As a side effect, the kernel creates a new <code>gpio12</code> node
inside the <code>/sys/class/gpio/</code> directory for the GPIO12
signal. The direction of the GPIO signal can be checked by reading the
<code>direction</code> property:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> /sys/class/gpio/gpio12/direction</span></code></pre></div>
<p>The value of <code>direction</code> is either <code>in</code> or
<code>out</code>. Here, we only want to read the GPIO signal, so the
value should be set to <code>in</code>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> in <span class="op">&gt;</span> /sys/class/gpio/gpio12/direction</span></code></pre></div>
<p>Finally, the value of the GPIO signal can be retrieved by reading the
<code>value</code> property. The <code>value</code> property reads 0
when the push-button SW0 is pressed, and 1 when the button is
inactive.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat /sys/class/gpio/gpio12/value</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">1</span></span></code></pre></div>
<p>We now press the button:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat /sys/class/gpio/gpio12/value</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">0</span></span></code></pre></div>
<p>It may be useful to know that those values are inverted when the
property <code>active_low</code> is set to 1 (default is 0).</p>
<p>We also note that <code>sysfs</code> is a virtual file system mounted
at <code>/sys</code>. The <code>gpioXX</code> nodes that we’ve created
above will be lost when the RPi is powered off.</p>
<h2 data-number="2.2" id="turning-the-leds-on-and-off-on-the-rpi"><span
class="header-section-number">2.2</span> Turning the LEDs on and off on
the RPi</h2>
<p>The LED0, LED1, and LED2 pins are connected to GPIO number 26, 20,
and 21, respectively. They correspond to the physical LEDs named LED1,
LED2, and LED3, c.f. figure 3.</p>
<figure id="fig:leds">
<img src="images/leds.png" style="width:60.0%"
alt="Figure 3: LEDs on the ASE fHAT board" />
<figcaption aria-hidden="true">Figure 3: LEDs on the ASE fHAT
board</figcaption>
</figure>
<p>To access LED0, we repeat the procedure described above:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> 26 <span class="op">&gt;</span> /sys/class/gpio/export</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> out <span class="op">&gt;</span> /sys/class/gpio/gpio26/direction</span></code></pre></div>
<p>LED0 can then be turned on and off by echoing 0 or 1 to the
<code>value</code> property:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> 1 <span class="op">&gt;</span> /sys/class/gpio/gpio26/value</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> 0 <span class="op">&gt;</span> /sys/class/gpio/gpio26/value</span></code></pre></div>
<p>Note that the 1 in <code>echo 1</code> above can be replaced by any
non-zero signed 32-bit integer value, which will be automatically
changed into a 1 when written to <code>value</code>.</p>
<h1 data-number="3"
id="accessing-hardware-devices-from-a-c-program"><span
class="header-section-number">3</span> Accessing hardware devices from a
C program</h1>
<p>Let us now write a C program that is able to interact with hardware
devices. We will use simple POSIX file-IO as described in [TLPI, Chapter
4] to switch LEDs on and off with an interval of 1 second. We assume
that the GPIO nodes of interest have been created in <code>sysfs</code>
using the methods described in the last section. Our bash script,
<code>gpio_setup.sh</code>, creates the GPIO nodes corresponding to the
three LEDS and two push-buttons.</p>
<p>Assuming that the node for GPIO26 corresponding to LED1 has been set
up properly, we can now open its <code>value</code> property using the
<code>O_RDWR</code> access mode for read/write access:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>fd_led <span class="op">=</span> open<span class="op">(</span><span class="st">&quot;/sys/class/gpio/gpio26/value&quot;</span><span class="op">,</span> O_RDWR<span class="op">);</span></span></code></pre></div>
<p>The LED can be turned on and off by writing the single character byte
‘1’ or ‘0’ to <code>value</code>. The code below will make LED1 blink
with a 1-second interval:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> low <span class="op">=</span> <span class="ch">&#39;0&#39;</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> high <span class="op">=</span> <span class="ch">&#39;1&#39;</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    write<span class="op">(</span>fd_led<span class="op">,</span> <span class="op">&amp;</span>low<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    sleep<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    write<span class="op">(</span>fd_led<span class="op">,</span> <span class="op">&amp;</span>low<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    sleep<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The final version of the program handles errors, interruption of the
loop by pressing CTRL+C, and takes an input parameter to choose which
one of the three red LEDs will be blinking. The program is
cross-compiled and transferred to the RPi as follows (or simply running
the provided Makefile):</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">arm-rpizw-gcc</span> <span class="at">-std</span><span class="op">=</span>gnu17 <span class="at">-Wall</span> <span class="at">-Wextra</span> <span class="at">-Werror</span> <span class="at">-o</span> blink blink.c </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">scp</span> blink root@10.9.8.2:blink</span></code></pre></div>
<p>Let us analyze what happens when we try to read from and write to the
<code>/sys/class/gpio/gpio26/value</code> node. This node is not a
<em>real</em> file, i.e. the read/write accesses will be managed by a
special kernel driver. A look into
<code>drivers/gpio/gpiolib-sysfs.c</code>, and in particular the
<code>value_store()</code> function, indicates that the buffer
containing the value read from the command line is converted to a signed
32-bit integer using the <code>kstrtol</code> kernel function. Then, the
value is converted into a boolean value via parameter conversion,
e.g. via a call to the <code>gpiod_set_value_nocheck()</code> function
in <code>drivers/gpio/gpiolib.c</code>. Therefore, the valid values that
can be written to the value attribute of GPIO26 are either 1) some valid
string representation of 0, e.g. “0”, “00”, “0000”, “0”, etc. Such a
value results in a ‘0’ being written to <code>value</code> (followed by
a newline character probably for aesthetic reasons when the content of
<code>value</code> is output to the terminal), or, 2) some valid string
representation of some non-zero signed 32-bit integer in the range from
-2147483648 to 2147483647. Such a value results in a ‘1’ being written
to <code>value</code>.</p>
<p>Finally, we also observe from the sources (the
<code>value_store()</code> function in
<code>drivers/gpio/gpiolib-sysfs.c</code>) that writing a buffer of
length 1 containing the char representation of a single digit to the
<code>value</code> node will be processed as above. In particular, we do
not even need to provide a null terminated string as input parameter,
but a single character byte, either ‘0’ or ‘1’, will suffice.</p>
<p>As a final remark we note that the above-described procedure for
accessing GPIO ports via sysfs is now deprecated and only works for
backward compatibility reasons, c.f. <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/Documentation/ABI/obsolete/sysfs-gpio?h=v5.16&amp;id=fe95046e960b4b76e73dc1486955d93f47276134">gpio:
ABI: mark the sysfs ABI as obsolete</a>.</p>
<p>We provide two example programs meant to be run on the RPi: -
<code>blink.c</code> blinks a single LED, - <code>blink_all.c</code>
blinks all three LEDS in a nice pattern.</p>
<p>Remember to run <code>gpio_setup.sh</code> after each reboot of the
RPi in order to create the required GPIO nodes in
<code>sysfs</code>.</p>
<p>We also provide another program, <code>capslock_blink.c</code>, which
is able to blink the CapsLock LED on a Linux Mint laptop.</p>
<h1 data-number="4" id="file-operations-to-i2c-devices"><span
class="header-section-number">4</span> File operations to I2C
devices</h1>
<p>The LM75 temperature sensor mounted on the ASE fHAT has an I2C
interface, c.f. figure 4 and <a
href="https://www.analog.com/media/en/technical-documentation/data-sheets/lm75.pdf">LM75:
Digital Temperature Sensor and Thermal Watchdog with 2-Wire Interface
Data Sheet</a>.</p>
<figure id="fig:lm75_fhat">
<img src="images/lm75_fhat.png" style="width:60.0%"
alt="Figure 4: LM75 temperature sensor on the ASE fHat." />
<figcaption aria-hidden="true">Figure 4: LM75 temperature sensor on the
ASE fHat.</figcaption>
</figure>
<p>A default driver <code>i2c-dev</code> allows I2C devices to be
controlled from user space through the character device
<code>/dev/i2c-&lt;X&gt;</code>, where <code>&lt;X&gt;</code> is the bus
number onto which the I2C adapter is connected, c.f. the kernel
documentation, <a
href="https://www.kernel.org/doc/html/v5.4/i2c/dev-interface.html">I2C
Device Interface</a> and [LDDD, Chapter 8]. The <code>i2c-dev</code>
driver needs to be loaded either manually with
<code>modprobe i2c-dev</code>, or automatically by adding in
<code>/etc/modules-load.d</code> a <code>.conf</code> file containing
the name of the module to load during boot. Additional information can
be found in <code>man modules-load.d</code>.</p>
<p><img src="images/i2c_dev.png" style="width:95.0%" /></p>
<p>In order to read and write data to the I2C device, we first need to
open the character device <code>/dev/i2c-1</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>i2c_fd <span class="op">=</span> open<span class="op">(</span><span class="st">&quot;/dev/i2c-1&quot;</span><span class="op">,</span> O_RDWR<span class="op">);</span></span></code></pre></div>
<p>Then we can execute a series of commands listed in
<code>include/uapi/linux/i2c-dev.h</code>, e.g. I2C_SLAVE, I2C_RETRIES,
I2C_FUNCS, etc. The address of the I2C device that we want to access can
be set by means of an <code>ioctl</code> call with the
<code>I2C_SLAVE</code> command:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> addr <span class="op">=</span> <span class="bn">0x48</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>ioctl<span class="op">(</span>i2c_fd<span class="op">,</span> I2C_SLAVE<span class="op">,</span> addr<span class="op">)</span></span></code></pre></div>
<p>What is the chip address? According to the LM75 documentation, the
address byte is <code>0b01001&lt;A2&gt;&lt;A1&gt;&lt;A0&gt;</code>,
which is equal to <code>0x48</code> when <code>A0=A1=A2=0</code>. The
R/W bit, which appears as the least significant bit of the address byte
in the diagram below, will be filled in automatically by the I2C driver.
Figure 4a in the LM75 manual describes a typical 2-byte read and is
reproduced below:</p>
<figure id="fig:LM75_read">
<img src="images/LM75_read.png" style="width:100.0%"
alt="Figure 5: LM75 read" />
<figcaption aria-hidden="true">Figure 5: LM75 read</figcaption>
</figure>
<p>We are now all set to read from and write to the LM75. The current
temperature measure can be read into a 2-byte
<code>read_buffer</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>read<span class="op">(</span>i2c_fd<span class="op">,</span> read_buffer<span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span></code></pre></div>
<p>If the <code>read</code> is successful then
<code>read_buffer[0]</code> should be a signed byte containing the
integer part of the temperature, and the most significant bit of
<code>read_buffer[1]</code> specifies whether 0.5 should be added to the
temperature. Concretely the read bytes can be converted to a floating
point value as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> t <span class="op">=</span> read_buffer<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+</span> <span class="op">(</span>read_buffer<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">7</span><span class="op">)</span> <span class="op">?</span> <span class="fl">0.5</span> <span class="op">:</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>We read the temperature with a fixed time interval in an infinite
loop. The application terminates when Ctrl+C is pressed or when the
process is killed from the terminal, e.g. using <code>kill</code>. The
program can be easily modified to light a LED and print a warning
message to the terminal when a fixed temperature threshold is crossed.
We handle SIGINT and SIGTERM signals explicitly such as to make sure the
alarm LED is turned off when the application is terminated.</p>
<p>Note that the LM75 has a Pointer register which determines which one
of the 4 data registers is selected for the next read/write operation.
The four data registers are Temperature (Pointer = 0x0), Configuration
(0x1), T_HYST (0x2), and T_OS (0x3). At power-up the Pointer register is
0x0 meaning that the LM75 is set up to read the Temperature register.
That is why we can start reading the temperature values right away after
the initial ioctl call.</p>
<p>The LM75 has an OS (Overtemperature Shutdown) output on pin 3, and
from the LM-75 manual: “the open-drain OS output asserts when the
temperature rises above the limit programmed into the T_OS register, and
becomes high impedance when the temperature falls below the limit set in
the T_HYST register.”</p>
<p>According to the LM75 manual Figure 5c, the T_OS (T_HIGH) can be set
by first setting the Pointer byte to 0x3 and writing the two bytes
representing the temperature upper threshold, such that</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>write<span class="op">(</span>i2c_fd<span class="op">,</span> <span class="op">(</span><span class="dt">signed</span> <span class="dt">char</span><span class="op">[]){</span><span class="dv">3</span><span class="op">,</span> <span class="dv">77</span><span class="op">,</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">7</span><span class="op">},</span> <span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<p>will set the T_OS register (Pointer reg. = 3) to 77.5 degrees
Celsius. The bit representation of -128 (i.e. 1 &lt;&lt; 7) is
0x1000.0000, i.e. the MSB is set to 1 meaning that 0.5 must be added to
the integer value contained in the first byte written (77). Since the
Pointer register was set to 3 during the write operation above, any
subsequent read will fetch the temperature upper threshold from the T_OS
register without having to re-set the Pointer register explicitly such
that</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>read<span class="op">(</span>i2c_fd<span class="op">,</span> read_buffer<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<p>should return [77, -128]. Consequently, the Pointer register must be
reset to 0 (the address of the Temperature register) before the
Temperature register can be read again. Following the LM75 manual Figure
5a, we first set the Pointer register,</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>write<span class="op">(</span>i2c_fd<span class="op">,</span> <span class="op">(</span><span class="dt">signed</span> <span class="dt">char</span><span class="op">[]){</span><span class="dv">0</span><span class="op">},</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>Then, each subsequent two-byte <code>read</code> will retrieved the
current value of the Temperature register:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>read<span class="op">(</span>i2c_fd<span class="op">,</span> read_buffer<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<p>Figure 6 shows the output of our <code>i2c_temp</code> program
running on the RPi.</p>
<figure id="fig:alarm">
<img src="images/alarm.png" style="width:100.0%"
alt="Figure 6: The temperature measured by the LM75 exceeds 30.5 degrees!" />
<figcaption aria-hidden="true">Figure 6: The temperature measured by the
LM75 exceeds 30.5 degrees!</figcaption>
</figure>
<h1 data-number="5"
id="accessing-temperature-measurements-from-the-rpis-http-server"><span
class="header-section-number">5</span> Accessing temperature
measurements from the RPi’s HTTP server</h1>
<p>The default homepage served by the RPi is located at
<code>/www/pages/index.html</code>. We let our application update the
index page periodically with the temperatures read on the LM75:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat /www/pages/index.html</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Temperature:</span> 29.5 degrees </span></code></pre></div>
<p>Temperature updates can then be read from the host computer by typing
<code>10.9.8.2</code> in the address bar of a web browser, or, even
better, using <code>netcat</code> by first creating a HTTP request:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">printf</span> <span class="st">&#39;GET / HTTP/1.1\r\nHost: 10.9.8.2\r\nConnection: close\r\n\r\n&#39;</span> <span class="op">&gt;</span> request</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat <span class="at">-A</span> request</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="ex">GET</span> / HTTP/1.1^M$</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Host:</span> 10.9.8.2^M$</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="ex">Connection:</span> close^M$</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="ex">^M$</span></span></code></pre></div>
<p>and then sending the request to 10.9.8.2 on port 80:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat request <span class="kw">|</span> <span class="ex">nc</span> 10.9.8.2 80</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ex">HTTP/1.1</span> 200 OK</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Content-Type:</span> text/html</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Accept-Ranges:</span> bytes</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="ex">ETag:</span> <span class="st">&quot;3369338944&quot;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="ex">Last-Modified:</span> Fri, 07 Feb 2020 16:14:02 GMT</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Content-Length:</span> 27</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="ex">Connection:</span> close</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="ex">Date:</span> Fri, 07 Feb 2020 16:14:01 GMT</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="ex">Server:</span> lighttpd/1.4.55</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="ex">Temperature:</span> 29.5 degrees  </span></code></pre></div>
<p>For a more succinct output, we may type:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat request <span class="kw">|</span> <span class="ex">nc</span> 10.9.8.2 80 <span class="kw">|</span> <span class="fu">grep</span> Temperatur</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Temperature:</span> 29.5 degrees  </span></code></pre></div>
</body>
</html>
