<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Linux device drivers with SPI</title>
  <style>
    html {
      font-family: monospace;
      font-size: 12pt;
      line-height: 1.25;
      color: #1a1a1a;
      background-color: #F5F5F0;
    }
    body {
      margin: 0 auto;
      max-width: 52em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: #F5F5F0;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: Blue;
    }
    a:visited {
      color: Blue;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      background-color: #E5E5E0;
      padding: .2em .4em;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      background-color: #E5E5E0;
      padding: 1em;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
  img {
    # padding:            2px;
    # border:             2px dashed #333;
    border:             2px solid #333;
    # background-color:   #3ee;
    # color:              #000;
    # height:             12em;
    # float:              right;
    # clear:              right;
    # margin-left:        1em;
    # margin-bottom:      1em;
    }

    #   pre, code {
    #     background-color:   lightyellow;
    #     font-family:        "Courier New";
    #     border-radius:      0.5em;
    #     }

    #   figCaption {
    #     display:            block;
    #   }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Linux device drivers with SPI</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#motivation" id="toc-motivation"><span
class="toc-section-number">1</span> Motivation</a></li>
<li><a href="#mcp3202---ad-converter"
id="toc-mcp3202---ad-converter"><span
class="toc-section-number">2</span> MCP3202 - A/D converter</a>
<ul>
<li><a href="#implementing-a-devicetree-overlay-for-the-mcp3202"
id="toc-implementing-a-devicetree-overlay-for-the-mcp3202"><span
class="toc-section-number">2.1</span> Implementing a Devicetree Overlay
for the MCP3202</a></li>
<li><a href="#blacklisting-spi-dev" id="toc-blacklisting-spi-dev"><span
class="toc-section-number">2.2</span> Blacklisting spi-dev</a></li>
<li><a href="#compiling-the-overlays"
id="toc-compiling-the-overlays"><span
class="toc-section-number">2.3</span> Compiling the overlays</a></li>
<li><a href="#installing-the-overlays"
id="toc-installing-the-overlays"><span
class="toc-section-number">2.4</span> Installing the overlays</a></li>
<li><a href="#implementing-the-driver"
id="toc-implementing-the-driver"><span
class="toc-section-number">2.5</span> Implementing the driver</a></li>
<li><a href="#testing" id="toc-testing"><span
class="toc-section-number">2.6</span> Testing</a></li>
</ul></li>
<li><a href="#mcp4802---da-converter."
id="toc-mcp4802---da-converter."><span
class="toc-section-number">3</span> MCP4802 - D/A converter.</a>
<ul>
<li><a href="#implementing-a-devicetree-overlay-for-the-mcp4802-device"
id="toc-implementing-a-devicetree-overlay-for-the-mcp4802-device"><span
class="toc-section-number">3.1</span> Implementing a Devicetree Overlay
for the MCP4802 device</a></li>
<li><a href="#probing-and-removing" id="toc-probing-and-removing"><span
class="toc-section-number">3.2</span> Probing and removing</a></li>
<li><a href="#spi-communication-with-the-mcp4802"
id="toc-spi-communication-with-the-mcp4802"><span
class="toc-section-number">3.3</span> SPI communication with the
MCP4802</a></li>
<li><a href="#testing-the-mcp4802-driver"
id="toc-testing-the-mcp4802-driver"><span
class="toc-section-number">3.4</span> Testing the MCP4802
driver</a></li>
</ul></li>
<li><a href="#mcp3202-and-mcp4802-working-together."
id="toc-mcp3202-and-mcp4802-working-together."><span
class="toc-section-number">4</span> MCP3202 and MCP4802 working
together.</a></li>
</ul>
</nav>
<h1 data-number="1" id="motivation"><span
class="header-section-number">1</span> Motivation</h1>
<p>Two following two devices are available on our fHAT:</p>
<ul>
<li>A/D converter MCP3202</li>
<li>D/A converter MCP4802</li>
</ul>
<p>Why do we want to implement an SPI device driver? Why do we need to
implement a device tree overlay?</p>
<p>SPI does not support hot-plugging. Hence, information about the SPI
bus number and other device information must be written in the device
tree.</p>
<p>Read BCM2835 Peripherals (RPi processor datablad) p.102-104 about
pinmux and p.160 about SPI.</p>
<h1 data-number="2" id="mcp3202---ad-converter"><span
class="header-section-number">2</span> MCP3202 - A/D converter</h1>
<p>The goal of the present section is to write an SPI driver for the
MCP3202.</p>
<p>The datasheet of the MCP3202 can be read here: <a
href="https://ww1.microchip.com/downloads/aemDocuments/documents/APID/ProductDocuments/DataSheets/21034F.pdf">MCP3202
Datasheet</a>.</p>
<p>First, we can see the eight pins of the MCP3202 A/D converter, c.f.
the ASE fHat schematics on Redweb:</p>
<!-- [![MCP3203 AD converter on the ASE fHat](images/adc_mcp3202_ase_fhat.png){width=60%}](images/adc_mcp3202_ase_fhat.png "MCP3202 ADC") -->
<figure>
<img src="images/adc_mcp3202_ase_fhat.png" style="width:60.0%"
alt="MCP3203 AD converter on the ASE fHat" />
<figcaption aria-hidden="true">MCP3203 AD converter on the ASE
fHat</figcaption>
</figure>
<p>Then, the ase fHat interface with the RPi is show below:</p>
<figure>
<img src="images/rpi_interface_ase_fhat.png" style="width:80.0%"
alt="RPI interface" />
<figcaption aria-hidden="true">RPI interface</figcaption>
</figure>
<!-- :::::::::::::: {.columns}
::: {.column width="40%"}
![RPI interface](images/rpi_interface_ase_fhat.png){width=80%}...
:::
::: {.column width="60%"}
![RPI interface](images/rpi_interface_ase_fhat.png){width=80%}
:::
:::::::::::::: -->
<p>So, we have the following signals:</p>
<pre class="plain"><code>CS_N  --SPI_SS0---&gt;  PIN 24 (SPI_SS0)  --&gt; GPIO8
 SDO  --SPI_MISO--&gt;  PIN 21 (SPI_MISO) --&gt; GPIO9
 SDI  --SPI_MOSI--&gt;  PIN 19 (SPI_MOSI) --&gt; GPIO10
SCLK  --SPI_CLK---&gt;  PIN 23 (SPI_CLK)  --&gt; GPIO11</code></pre>
<p>The GPIO mappings that we listed above can be found in the diagram
below, c.f. <code>RPI-ZERO-V1_3_reduced.pdf</code> on Redweb:</p>
<figure>
<img src="images/dni_rpi_zero.png" style="width:80.0%"
alt="GPIO connector" />
<figcaption aria-hidden="true">GPIO connector</figcaption>
</figure>
<p>We look up page 102 in the <a
href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">BCM2835
Reference Manual</a> where the alternative functions of the GPIO pins
are described. The relevant part of
<code>Table 6-31 GPIO Pins Alternative Function Assignment</code> is
shown below.</p>
<figure>
<img src="images/alternative_function_bcm2835.png" style="width:40.0%"
alt="GPIO Pins Alternative Function Assigment" />
<figcaption aria-hidden="true">GPIO Pins Alternative Function
Assigment</figcaption>
</figure>
<p>The name of the alternative function has the following format:</p>
<pre class="plain"><code>SPI&lt;bus number&gt;_CE&lt;chip select number&gt;_N</code></pre>
<p>We deduce that the SPI bus number is 0, and the chip-select number is
0.</p>
<p>From the MCP3202 manual, we get the SPI max frequency:</p>
<pre class="plain"><code>Clock frequency, f_CLK:
- Max 1.8 MHz with VDD=5V
- Max 0.9 MHz with VDD=2.7V</code></pre>
<p>So with a VDD=3.3V we should be on the safe side with a max frequency
of 900 kHz.</p>
<p>The available PHAse,POLarity modes, (0,0) and (1,1), are given on the
first page of the MCP3202 manual.</p>
<p>To sum up for the MCP3202, we have:</p>
<ol type="1">
<li>SPI bus number = 0.</li>
<li>SPI chip-select (SS) number = 0.</li>
<li>SPI max clock frequency: 900 kHz.</li>
<li>SPI clock mode: Two modes (0,0) and (1,1).</li>
</ol>
<h2 data-number="2.1"
id="implementing-a-devicetree-overlay-for-the-mcp3202"><span
class="header-section-number">2.1</span> Implementing a Devicetree
Overlay for the MCP3202</h2>
<p>We now have enough information to create device tree overlays for the
MCP3202.</p>
<p>The structure of device trees is described in [LDDD, Section 5] and
we will use the online <a
href="https://devicetree-specification.readthedocs.io/en/v0.3/index.html">Devicetree
Specification</a>.</p>
<p>Basically, nodes in a devicetree are of the form:</p>
<pre class="plain"><code>[label:] node-name[@unit-address] {
    [properties definitions]
    [child nodes]
};</code></pre>
<p>The <code>address</code> is optional depending on whether the device
is addressable, and its interpretation depends on the type of device.
Let us examine our MCP3202 devicetree overlay:</p>
<pre class="plain"><code>/dts-v1/;
/plugin/;

/ {
    compatible = &quot;brcm,bcm2835&quot;, &quot;brcm,bcm2708&quot;;

    fragment@0 {    
        target = &lt;&amp;spi0&gt;; // SPI Bus 0
        __overlay__ {
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            mcp3202:mcp3202@0 {
                compatible = &quot;ase, mcp3202_drv&quot;;
                reg = &lt;0&gt;; // SPI Chip Select 0
                spi-max-frequency = &lt;900000&gt;; /* 900 KHz */
                /* spi-cpha; */ /* Comment in to set CPHA */
                /* spi-cpol; */ /* Comment in to set CPOL */
                status = &quot;okay&quot;;
            };
        };
    };
};
</code></pre>
<p>There is a single fragment in this overlay, so the index is simply
<code>0</code>. A new fragment <code>fragment@N</code> indexed by
<code>N</code> must be created for each node that needs to be
overlayed.</p>
<ul>
<li><code>target = &lt;&amp;spi0&gt;;</code>: Our fragment will modify
the node labelled <code>spi0</code>.</li>
<li>The node <code>__overlay__</code> contains the changes that should
be applied to the <code>spi0</code> node. Properties can be added or
modified, and new nodes can be added.
<ul>
<li>The properties <code>#address-cells = &lt;1&gt;;</code> and
<code>#size-cells = &lt;0&gt;;</code> are set, otherwise a warning is
emitted when compiling the overlay.</li>
<li>The <code>mcp3202@0</code> node is labelled <code>mcp3202</code> and
<code>0</code> is the primary address used to access the device, more
precisely for an SPI device, <code>0</code> is the chip select (CS)
index.</li>
</ul></li>
</ul>
<p>Documentation can be found in
<code>Documentation/devicetree/bindings/spi/spi-controller.yaml</code>
and [LDD, Chapter 9, page 301].</p>
<p>For the slave nodes <code>mcpXXXX@N</code> the required properties
are:</p>
<ul>
<li><code>compatible</code>: The string that is matched with the
driver’s compatible string.</li>
<li><code>reg</code>: The chip select index of the device.</li>
<li><code>spi-max-frequency</code>: The maximum SPI clocking speed in
Hz</li>
</ul>
<p>Optional flag properties that can be present (set) or left out
(unset):</p>
<ul>
<li><code>spi-cpol</code>: If present, the device requires inverse clock
polarity mode.</li>
<li><code>spi-cpha</code>: If present, the device requires inverse clock
phase mode.</li>
</ul>
<p>We are using the first CS (Chip Select) line, with
<code>reg = &lt;0&gt;</code>. We set <code>spi-max-frequency</code> to
900 KHz to be the default clock speed our MCP3202 SPI device will
operate at. The clock phase (<code>spi-cpha</code>) and clock polarity
(<code>spi-cpol</code>) can be set to (1,1) by uncommenting the two
corresponding lines. Otherwise, it can be left commented out for (CPHA,
CPOL)=(0,0). The MCP3202 and the MCP4802 both support (0,0) and (1,1)
modes.</p>
<h2 data-number="2.2" id="blacklisting-spi-dev"><span
class="header-section-number">2.2</span> Blacklisting spi-dev</h2>
<p>The SPI bus is already allocated to the default driver spi-dev.
First, we create an overlay that will be loaded at boot time.</p>
<pre class="plain"><code>/dts-v1/;
/plugin/;

/ {
    compatible = &quot;brcm,bcm2835&quot;, &quot;brcm,bcm2708&quot;;

    /* Disable spi-dev for spidev0.0 */
    fragment@0 {
        target = &lt;&amp;spidev0&gt;;
        __overlay__ {
            status = &quot;disabled&quot;;
        };
    };

    /* Disable spi-dev for spidev0.1 */
    fragment@1 {
        target = &lt;&amp;spidev1&gt;;
        __overlay__ {
            status = &quot;disabled&quot;;
        };
    };
};</code></pre>
<p>We start by disabling the default spi-dev interface that targets SPI
Bus 0 because we want to write our own driver. According to [LTTT,
Chapter 9], the device exposed by the default spidev interface is
<code>/dev/spidevX.Y</code> where X is the bus number and Y is the Chip
Select index. And similarly for
<code>/sys/class/spidev/spidevX.Y</code>. Here, we are disabling the
character device node on bus number 0 for CS 0 and CS 1, otherwise we
would get the following error message when trying to load the MCP3202
driver and, later on, the MCP4802 driver:</p>
<figure>
<img src="images/dmesg_CS0_CS1.png"
alt="Error message in dmesg when spidev0.x and spidev1.x are not disabled." />
<figcaption aria-hidden="true">Error message in <code>dmesg</code> when
spidev0.x and spidev1.x are not disabled.</figcaption>
</figure>
<h2 data-number="2.3" id="compiling-the-overlays"><span
class="header-section-number">2.3</span> Compiling the overlays</h2>
<p>Overlays can be compiled manually. The overlay
<code>mcp3202_drv-overlay.dts</code> can be compiled into a compiled
overlay <code>mcp3202_drv.dtbo</code> with the following command:</p>
<pre class="plain"><code>dtc -@ -I dts -O dtb -o mcp3202_drv.dtbo mcp3202_drv-overlay.dts</code></pre>
<p>The compiled overlay can be inserted manually into the
devicetree:</p>
<pre class="plain"><code>dtoverlay mcp3202_drv.dtbo</code></pre>
<p>and removed from the devicetree:</p>
<pre class="plain"><code>dtoverlay -r mcp3202_drv.dtbo</code></pre>
<p>The manual method is useful for testing the <code>probe</code> and
<code>remove</code> callbacks. It is a bit unclear whether removing an
overlay from the devicetree is <em>stable</em>. We noted that if we do
the following:</p>
<ol type="1">
<li>insert <code>A.dtbo</code>, then</li>
<li>insert <code>B.dtbo</code>, then</li>
<li>remove <code>A.dtbo</code>,</li>
</ol>
<p>then the overlay <code>B</code> will be automatically removed and
probed again, i.e. the behaviour is similar to removing arbitrary
elements from a stack.</p>
<p>In other words, our driver could be removed and probed again
automatically, due to changes made to the device tree independently of
our driver.</p>
<h2 data-number="2.4" id="installing-the-overlays"><span
class="header-section-number">2.4</span> Installing the overlays</h2>
<p>We need to blacklist the default <code>spidev</code> driver that
holds the SPI bus. For our version of the kernel, the procedure goes as
follows:</p>
<ol type="1">
<li><p>Blacklist the default <code>spidev</code> driver that no longer
will be loaded automatically during the boot process.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;blacklist spidev&quot;</span> <span class="op">&gt;&gt;</span> /etc/modprobe.d/blacklist.conf</span></code></pre></div></li>
<li><p>Copy the compiled device tree overlay
<code>spidev_blacklist.dtbo</code> to <code>/boot/overlays</code>.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> spidev_blacklist.dtbo /boot/overlays/</span></code></pre></div></li>
<li><p>Add <code>dtoverlay=spidev_blacklist</code> to
<code>/boot/config.txt</code> such that the overlay is loaded
automatically.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;dtoverlay=spidev_blacklist&quot;</span> <span class="op">&gt;&gt;</span> /boot/config.txt</span></code></pre></div></li>
</ol>
<p>We could load devicetree overlays for the MCP3202 and MCP4802 at boot
time as well. However, we will load them manually instead, in order to
experiment with the driver’s <code>probe</code> and <code>remove</code>
callbacks.</p>
<p>We have written a couple of shell scripts that are able to install
and uninstall a device tree overlay. As an example, in the
uninstallation script all lines referencing MCP3202 case-insensitively
in <code>/boot/config.txt</code> can be removed using:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sed</span> <span class="at">-i</span> <span class="st">&#39;/[mM][cC][pP]3202/d&#39;</span> /boot/config.txt</span></code></pre></div>
<p>Fun fact: <code>sed -i '/mcp3202/Id' /boot/config.txt</code> works on
my Linux Mint distribution, but the case-insensitivity option
<code>I</code> is not portable, and does <em>not</em> work on the Linux
distribution installed on our RPi.</p>
<p>When the overlays are properly loaded we should have the two
nodes.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ls <span class="at">-l</span> /sys/firmware/devicetree/base/soc/spi\@7e204000/ <span class="kw">|</span> <span class="fu">grep</span> mcp</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ex">drwxr-xr-x</span>    2 root     root             0 Feb  7 11:11 mcp3202@0</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ex">drwxr-xr-x</span>    2 root     root             0 Feb  7 11:11 mcp4802@1</span></code></pre></div>
<h2 data-number="2.5" id="implementing-the-driver"><span
class="header-section-number">2.5</span> Implementing the driver</h2>
<h3 data-number="2.5.1" id="probe-and-remove"><span
class="header-section-number">2.5.1</span> Probe and remove</h3>
<p>Our MCP3202 driver controls two (<code>N_SPI_DEVICES</code>) devices
with respective minors 0 and 1. <code>spi_setup</code> initializes the
SPI mode and clock rate of an <code>spi_device</code>. Note that the
default value of <code>bits_per_word</code> is 0 and signifies that
words are 8 bits long, so we don’t need to write
<code>pdev-&gt;bits_per_word = 8</code>. For each minor number we create
a new device, here <code>/dev/adc0</code> and <code>/dev/adc1</code>.
Then we update our mapping from minor numbers to channel numbers.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mcp3202_probe<span class="op">(</span><span class="kw">struct</span> spi_device <span class="op">*</span>pdev<span class="op">)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>spi_devs_cnt <span class="op">&gt;=</span> N_SPI_DEVICES<span class="op">)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        dev_err<span class="op">(&amp;</span>pdev<span class="op">-&gt;</span>dev<span class="op">,</span> <span class="st">&quot;Too many SPI devices for driver</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>ENODEV<span class="op">;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    spi_setup<span class="op">(</span>pdev<span class="op">);</span> <span class="co">// bits_per_word = default (0), i.e. eight bit bytes.</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create two devices, one for each ADC.</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minor <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> device <span class="op">*</span>newdev<span class="op">;</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>minor <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> minor <span class="op">&lt;</span> N_SPI_DEVICES<span class="op">;</span> minor<span class="op">++)</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        newdev <span class="op">=</span> device_create<span class="op">(</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>            drv<span class="op">-&gt;</span>class<span class="op">,</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>            NULL<span class="op">,</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            MKDEV<span class="op">(</span>MAJOR<span class="op">(</span>drv<span class="op">-&gt;</span>nr<span class="op">),</span> minor<span class="op">),</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>            NULL<span class="op">,</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>            drv<span class="op">-&gt;</span>device_name<span class="op">[</span>minor<span class="op">]);</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>err <span class="op">=</span> IS_ERR<span class="op">(</span>newdev<span class="op">)))</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>            ERRGOTO<span class="op">(</span>device_create_failed<span class="op">,</span> <span class="st">&quot;device_create: FAIL</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        adc<span class="op">[</span>minor<span class="op">].</span>spi <span class="op">=</span> pdev<span class="op">;</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>        adc<span class="op">[</span>minor<span class="op">].</span>channel <span class="op">=</span> minor<span class="op">;</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        spi_devs_cnt<span class="op">++;</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> error handling <span class="op">...</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>remove</code> callback destroys the 2 created devices and
resets the number of registered devices such that they can be probed
again later.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mcp3202_remove<span class="op">(</span><span class="kw">struct</span> spi_device <span class="op">*</span>pdev<span class="op">)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> minor <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> minor <span class="op">&lt;</span> spi_devs_cnt<span class="op">;</span> minor<span class="op">++)</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        device_destroy<span class="op">(</span>drv<span class="op">-&gt;</span>class<span class="op">,</span> MKDEV<span class="op">(</span>MAJOR<span class="op">(</span>drv<span class="op">-&gt;</span>nr<span class="op">),</span> minor<span class="op">));</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    spi_devs_cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="2.5.2" id="spi-communication"><span
class="header-section-number">2.5.2</span> SPI communication</h3>
<p>The output produced by the A/D converter is a function of the input
signal</p>
<pre class="plain"><code>output = V_IN * 4096 / VDD</code></pre>
<p>where <code>V_IN</code> is the analog input voltage and
<code>VDD</code> is the supply voltage (3.3V). So</p>
<pre class="plain"><code>V_IN = ouput * VDD / 4096</code></pre>
<p>Figure 1 shows how the MCP3202 can be interfaced with a SPI port.</p>
<figure id="fig:mcp3202_comm_0_0">
<img src="images/mcp3202_comm_0_0.png"
alt="Figure 1: SPI Communication using 8-bit segments (Mode 0,0: SCLK idles low)." />
<figcaption aria-hidden="true">Figure 1: SPI Communication using 8-bit
segments (Mode 0,0: SCLK idles low).</figcaption>
</figure>
<p>The code of the <code>read</code> callback is explained below.
Communication with the MCP3202 A/D converter goes as follows:</p>
<ul>
<li>MOSI line:
<ol type="1">
<li>Seven zero bits followed by one start bit.</li>
<li>Three configuration bits:
<ul>
<li><code>SGL/DIFF=1</code> to select single-ended mode.</li>
<li><code>ODD/SIGN</code> selects which channel is used.</li>
<li><code>MSBF=1</code> for most significant bit first mode.</li>
</ul></li>
</ol></li>
<li>MISO line:
<ol type="1">
<li>Three unknown bits, one NULL bit, and 3 data bits (most
significant).</li>
<li>Eight data bits.</li>
</ol></li>
</ul>
<p>In practice, a message is composed of 3 transfers as shown in the
code below.</p>
<p>The two 8-bit data buffers received on the MISO line are concatenated
into a single 12-bit value. Then the 12-bit value is transformed into a
voltage using the formula above. Note that printing to the terminal as
we do here in a synchronous fashion may slow down the driver
tremendeously. In a production driver the printing should be done
asynchronously.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ssize_t</span> mcp3202_read<span class="op">(</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> file <span class="op">*</span>filep<span class="op">,</span> <span class="dt">char</span> __user <span class="op">*</span>buf<span class="op">,</span> <span class="dt">size_t</span> count<span class="op">,</span> loff_t <span class="op">*</span>offset<span class="op">)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> spi_transfer t<span class="op">[</span><span class="dv">3</span><span class="op">];</span> <span class="co">// Three transfers of 8-bit each = 2 x 12 bits</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>t<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>t<span class="op">));</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    u8 tx0<span class="op">,</span> tx1<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    u8 rx1<span class="op">,</span> rx2<span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> spi_message m<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    spi_message_init<span class="op">(&amp;</span>m<span class="op">);</span> <span class="co">// zeroes out entries and initializes link-list.</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minor <span class="op">=</span> iminor<span class="op">(</span>filep<span class="op">-&gt;</span>f_inode<span class="op">);</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span>spi <span class="op">=</span> adc<span class="op">[</span>minor<span class="op">].</span>spi<span class="op">;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The first byte transmitted to the A/D converter contains seven leading</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// zeros before the start bit.</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    tx0 <span class="op">=</span> <span class="bn">0x00000001</span><span class="op">;</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Single Ended Mode, Channel 0, MSB.</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    tx1 <span class="op">=</span> adc<span class="op">[</span>minor<span class="op">].</span>channel <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>              <span class="op">?</span> <span class="op">(</span>SGL_DIFF <span class="op">|</span> MSB<span class="op">)</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>              <span class="op">:</span> <span class="op">(</span>SGL_DIFF <span class="op">|</span> ODD_SIGN <span class="op">|</span> MSB<span class="op">);</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">0</span><span class="op">].</span>tx_buf <span class="op">=</span> <span class="op">&amp;</span>tx0<span class="op">;</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">0</span><span class="op">].</span>rx_buf <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">0</span><span class="op">].</span>len <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    spi_message_add_tail<span class="op">(&amp;</span>t<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">1</span><span class="op">].</span>tx_buf <span class="op">=</span> <span class="op">&amp;</span>tx1<span class="op">;</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">1</span><span class="op">].</span>rx_buf <span class="op">=</span> <span class="op">&amp;</span>rx1<span class="op">;</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">1</span><span class="op">].</span>len <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    spi_message_add_tail<span class="op">(&amp;</span>t<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">2</span><span class="op">].</span>tx_buf <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">2</span><span class="op">].</span>rx_buf <span class="op">=</span> <span class="op">&amp;</span>rx2<span class="op">;</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">2</span><span class="op">].</span>len <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>    spi_message_add_tail<span class="op">(&amp;</span>t<span class="op">[</span><span class="dv">2</span><span class="op">],</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> err <span class="op">=</span> spi_sync<span class="op">(</span>m<span class="op">.</span>spi<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>err <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>        pr_err<span class="op">(</span><span class="st">&quot;spi_sync: FAIL&quot;</span><span class="op">);</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err<span class="op">;</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="op">((</span>rx1 <span class="op">&amp;</span> <span class="bn">0xF</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">|</span> rx2<span class="op">;</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V_dd <span class="op">=</span> <span class="dv">33</span><span class="op">;</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V_in <span class="op">=</span> <span class="op">(</span>result <span class="op">*</span> V_dd<span class="op">)</span> <span class="op">/</span> <span class="dv">4096</span><span class="op">;</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V_in1 <span class="op">=</span> V_in <span class="op">/</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V_in2 <span class="op">=</span> V_in <span class="op">%</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> kbuf<span class="op">[</span>BUFLEN<span class="op">];</span></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len <span class="op">=</span> count <span class="op">&lt;</span> BUFLEN <span class="op">?</span> count <span class="op">:</span> BUFLEN<span class="op">;</span></span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>    len <span class="op">=</span> snprintf<span class="op">(</span>kbuf<span class="op">,</span> len<span class="op">,</span> <span class="st">&quot;</span><span class="sc">%d</span><span class="st">.</span><span class="sc">%d</span><span class="st">V (rx1: 0x</span><span class="sc">%02x</span><span class="st">, rx2: 0x</span><span class="sc">%02x</span><span class="st">)</span><span class="sc">\r</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>                   V_in1<span class="op">,</span> V_in2<span class="op">,</span> rx1 <span class="op">&amp;</span> <span class="bn">0xF</span><span class="op">,</span> rx2<span class="op">);</span></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>    len<span class="op">++;</span></span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>copy_to_user<span class="op">(</span>buf<span class="op">,</span> kbuf<span class="op">,</span> len<span class="op">))</span></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>EIO<span class="op">;</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">+=</span> len<span class="op">;</span> <span class="co">// or += count</span></span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> len<span class="op">;</span></span></code></pre></div>
<h3 data-number="2.5.3" id="a-note-on-the-dev_-macros"><span
class="header-section-number">2.5.3</span> A note on the
<code>dev_*()</code> macros</h3>
<p>The useful macros <code>dev_info</code>, <code>dev_err</code>,… write
a message in <code>dmesg</code> with a level of severity. The message is
prefixed by some driver information, e.g. name, bus and CS. As an
example if we call <code>dev_*</code> in the <code>probe</code> function
of the <code>mpc3202</code> driver,</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>dev_info<span class="op">(&amp;</span>pdev<span class="op">-&gt;</span>dev<span class="op">,</span> <span class="st">&quot;This is a dev_info message.&quot;</span><span class="op">);</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>dev_err<span class="op">(&amp;</span>pdev<span class="op">-&gt;</span>dev<span class="op">,</span> <span class="st">&quot;This is a dev_err message.&quot;</span><span class="op">);</span></span></code></pre></div>
<p>we get the following output in <code>dmesg</code> when the device is
probed:</p>
<p><img src="images/dmesg_dev_info.png" /></p>
<p>Obviously we could hard code in our driver the prefixed information,
but <code>dev_*()</code> offers a consistent way to do so.</p>
<h2 data-number="2.6" id="testing"><span
class="header-section-number">2.6</span> Testing</h2>
<h3 data-number="2.6.1" id="wavegen-screenshot"><span
class="header-section-number">2.6.1</span> Wavegen screenshot</h3>
<p><img src="images/mcp3202_CH0_2300mV.png" /></p>
<p>The GIF below demonstrates how <code>/dev/adc0</code> and
<code>/dev/adc1</code> can be read in parallel.</p>
<p><img src="images/mcp3202_adc0_sin_adc1_square.gif" /></p>
<h3 data-number="2.6.2" id="logic-screenshot"><span
class="header-section-number">2.6.2</span> Logic screenshot</h3>
<!-- 
<img src="images/POL0_PHA0_MSB_CH1.png" alt="" width="1500"> -->
<p><img src="images/mcp3202_CH0_logic_2300mv.png" /></p>
<p>We trigger on the falling edge of CS (Select).</p>
<p>Looking at the MOSI signal, i.e. our transfers to the device, the
first segment is the initialization byte <code>0x01=0b0000'0001</code>
and the second segment is the configuration byte
<code>0xA0=0b1010'0000</code>, with <code>SGL/DIFF=1</code>
(single-ended mode), <code>ODD/SIGN=0</code> (channel 0), and
<code>MSBF=1</code> (most significant bit first).</p>
<p>On the MISO signal we get <code>0x0B</code> followed by
<code>0x28</code>, i.e. <code>output = 0x0B28 = 2856</code>, and so the
voltage is <code>V_IN = 2856*3.3V/4096 = 2.3V</code> as expected.</p>
<p>Similarly, with channel 1 and a desired voltage of 1.5V. On the MOSI
signal the configuration byte is <code>0xE0=0b1110'000</code> which is
similar to the previous configuration byte but this time with
<code>ODD/SIGN=1</code> (channel 1).</p>
<p>On the MISO signal we get 0x07 followed by 0x47, i.e. output = 0x0747
= 1863 and so the voltage is V_IN = 1863*3.3V/4096 = 1.5V as
expected.</p>
<figure>
<img src="images/mcp3202_CH1_logic_1500mv.png"
alt="Mode PHA=0,POL=0, the clock idles low." />
<figcaption aria-hidden="true">Mode <code>PHA=0,POL=0</code>, the clock
idles low.</figcaption>
</figure>
<p>Back to the overlay if we add the <code>spi-cpha;</code> and
<code>spi-cpol;</code> lines to the mcp3202@0 node, we switch to mode
<code>PHA=1,POL=1</code>, and we see that now the clock idles in the
<em>high</em> state.</p>
<figure>
<img src="images/mcp3202_CH1_logic_1500mv_MODE11.png"
alt="Mode PHA=1,POL=1, the clock idles high." />
<figcaption aria-hidden="true">Mode <code>PHA=1,POL=1</code>, the clock
idles high.</figcaption>
</figure>
<h1 data-number="3" id="mcp4802---da-converter."><span
class="header-section-number">3</span> MCP4802 - D/A converter.</h1>
<p>Next we look into the MCP 4802 DAC, c.f. <a
href="http://ww1.microchip.com/downloads/en/DeviceDoc/20002249B.pdf">MCP4802
Data Sheet</a>.</p>
<figure>
<img src="images/dac_mcp4802_ase_fhat.png" style="width:60.0%"
alt="The MCP4802 D/A converter." />
<figcaption aria-hidden="true">The MCP4802 D/A converter.</figcaption>
</figure>
<p>The following signals and GPIOs can be read from the diagrams
above:</p>
<pre class="plain"><code>Chip Select Input:  CS_N --SPI_SS1--&gt; PIN 26 --&gt; GPIO7
Serial Clock Input: SCK --SPI_CLK--&gt;  PIN 23 --&gt; GPIO11
Serial Data Input:  SDI --SPI_MOSI--&gt; PIN 19 --&gt; GPIO10</code></pre>
<p>From the alternative functions table below, we get that the SPI bus
number is still 0, but the chip-select number is now 1.</p>
<p><img src="images/alternative_function_bcm2835.png" /></p>
<p>There is an additional signal <code>LDAC</code>. It idles in the high
state, and when it is driven low, the input registers are transferred
simultaneously to the output register, V_OUTA and V_OUTB.</p>
<pre class="plain"><code>Latch DAC Input: LDAC_N --DAC_LD--&gt; PIN 29 --&gt; GPIO5</code></pre>
<p>The clock frequency is 20 MHz. In Section 5.1 of the manual it is
stated that mode <code>0,0</code> and <code>1,1</code> are supported, as
it was the case for the MCP3202 A/D converter.</p>
<p>To sum up for the MCP4802, we have:</p>
<ol type="1">
<li>SPI bus number = 0.</li>
<li>SPI chip-select (SS) number = 1.</li>
<li>SPI max clock frequency: 20 MHz.</li>
<li>SPI clock mode: Two modes (0,0) and (1,1).</li>
<li>Latch DAC INPUT: Drive GPIO5 low and high again to update OUT
registers.</li>
</ol>
<h2 data-number="3.1"
id="implementing-a-devicetree-overlay-for-the-mcp4802-device"><span
class="header-section-number">3.1</span> Implementing a Devicetree
Overlay for the MCP4802 device</h2>
<p>The device tree overlay for the MCP4802 is shown below:</p>
<pre class="plain"><code>/dts-v1/;
/plugin/;

/ {
    compatible = &quot;brcm,bcm2835&quot;, &quot;brcm,bcm2708&quot;;

    fragment@0 {    
        target = &lt;&amp;spi0&gt;; // SPI Bus 0
        __overlay__ {
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            mcp4802:mcp4802@1 {
                compatible = &quot;ase, mcp4802_drv&quot;;
                reg = &lt;1&gt;; // SPI Chip Select 1
                /* spi-cpha; */ /* Comment in to set CPHA */
                /* spi-cpol; */ /* Comment in to set CPOL */
                spi-max-frequency = &lt;1000000&gt;; /* 1 MHz to be safe :) */

                /* LDAC on GPIO5, IN. Here, 0=IN and 1=OUT.*/
                gpios = &lt;&amp;gpio 5 1&gt;;
                /* Custom parameter. Default OUT value for GPIO5. */
                default_output_value = &lt;0x1&gt;;
                status = &quot;okay&quot;;
            };
        };
    };
};</code></pre>
<h2 data-number="3.2" id="probing-and-removing"><span
class="header-section-number">3.2</span> Probing and removing</h2>
<p>Probing MCP4802 is similar to probing the MCP3202. We request the
GPIO needed for the LDAC signal. We get GPIO information from the device
tree.</p>
<pre class="plain"><code>gpios = &lt;&amp;gpio 5 1&gt;;
default_output_value = &lt;0x1&gt;;</code></pre>
<p>So, GPIO nr. is <code>5</code>, direction is <em>output</em>
(<code>1</code>), and initial value is <code>1</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mcp4802_probe<span class="op">(</span><span class="kw">struct</span> spi_device <span class="op">*</span>pdev<span class="op">)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> </span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span>err <span class="op">=</span> of_gpio_count<span class="op">(</span>pdev<span class="op">-&gt;</span>dev<span class="op">.</span>of_node<span class="op">))</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> handle error<span class="op">...</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err<span class="op">;</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    drv<span class="op">-&gt;</span>ngpios <span class="op">=</span> err<span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>drv<span class="op">-&gt;</span>ngpios <span class="op">!=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        dev_err<span class="op">(&amp;</span>pdev<span class="op">-&gt;</span>dev<span class="op">,</span> <span class="st">&quot;too many gpios</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>EINVAL<span class="op">;</span> <span class="co">// Incorrectly formed GPIOS property in our DT.</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    gpio_num <span class="op">=</span> of_get_gpio<span class="op">(</span>pdev<span class="op">-&gt;</span>dev<span class="op">.</span>of_node<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>gpio_is_valid<span class="op">(</span>gpio_num<span class="op">))</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We ignore EPROBE_DEFER here?</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        dev_err<span class="op">(&amp;</span>pdev<span class="op">-&gt;</span>dev<span class="op">,</span> <span class="st">&quot;failed to get gpio number.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> gpio_num<span class="op">;</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    ldac_gpio<span class="op">.</span>gpio_nr <span class="op">=</span> gpio_num<span class="op">;</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> of_gpio_flags direction<span class="op">;</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    of_get_gpio_flags<span class="op">(</span>pdev<span class="op">-&gt;</span>dev<span class="op">.</span>of_node<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>direction<span class="op">);</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    ldac_gpio<span class="op">.</span>direction <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>direction<span class="op">;</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>    u32 default_output_value<span class="op">;</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>    of_property_read_u32<span class="op">(</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>        pdev<span class="op">-&gt;</span>dev<span class="op">.</span>of_node<span class="op">,</span> <span class="st">&quot;default_output_value&quot;</span><span class="op">,</span> <span class="op">&amp;</span>default_output_value<span class="op">);</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span>err <span class="op">=</span> gpio_request<span class="op">(</span>ldac_gpio<span class="op">.</span>gpio_nr<span class="op">,</span> ldac_gpio<span class="op">.</span>label<span class="op">))</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>        ERRGOTO<span class="op">(</span>gpio_request_failed<span class="op">,</span> <span class="st">&quot;gpio_request: FAIL</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>    err <span class="op">=</span> <span class="op">(</span>ldac_gpio<span class="op">.</span>direction <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> gpio_direction_input<span class="op">(</span>ldac_gpio<span class="op">.</span>gpio_nr<span class="op">)</span></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>                                     <span class="op">:</span> gpio_direction_output<span class="op">(</span>ldac_gpio<span class="op">.</span>gpio_nr<span class="op">,</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>                                                          default_output_value<span class="op">);</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>err <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>        ERRGOTO<span class="op">(</span>gpio_direction_failed<span class="op">,</span> <span class="st">&quot;gpio_direction_input: FAIL</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>    spi_setup<span class="op">(</span>pdev<span class="op">);</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> same as MCP3202 probe<span class="op">...</span></span></code></pre></div>
<p>The <code>remove</code> callback is similar to the MCP3202
counterpart, however we also need to call <code>gpio_free()</code>.</p>
<h2 data-number="3.3" id="spi-communication-with-the-mcp4802"><span
class="header-section-number">3.3</span> SPI communication with the
MCP4802</h2>
<p>We add a <code>gpios</code> property since LDAC is controlled by
GPIO5, c.f. Write Command for MCP4802 (8-bit DAC) [BCM4802 manual,
Figure 5.3]:</p>
<figure>
<img src="images/mcp4802_write_command.png"
alt="Write Command for MCP4802 (8-bit DAC)." />
<figcaption aria-hidden="true">Write Command for MCP4802 (8-bit
DAC).</figcaption>
</figure>
<p>The LDAC signal idles in a high state, and the output registers, OUTA
and OUTB, are first updated simultaneously when LDAC is brought to a low
state.</p>
<p>The write command register for MCP4802 (8-bit DAC) is split over 2
bytes, c.f. page 22 of the BCM4802 Manual:</p>
<p><img src="images/mcp4802_signal_info.png" /></p>
<p>What we need to transmit:</p>
<ol type="1">
<li>Three configuration bits:
<ul>
<li>A/B: 0 to write to <code>/dev/dac0</code>, 1 to write to
<code>/dev/dac1</code>.</li>
<li>GA: We setting to 0 or 1 depending on the value we want to
write.</li>
<li>SHDN: We set it to 1.</li>
</ul></li>
<li>Eight data bits.</li>
</ol>
<p>Depending on the value that we want to write we set the multiplier
<code>GA</code> to <code>0</code> or <code>1</code>. Note that if we
insert <code>VREF=2048mV</code> in the formula for <code>GA</code> shown
above, it reduces to:</p>
<pre class="plain"><code>GA=1: VOUT = (D &lt;&lt; 4)/2
GA=0: VOUT = (D &lt;&lt; 4)</code></pre>
<p><code>VOUT</code> is the voltage in mV that we want to output and
<code>D</code> is the 8-bit value of the bit representation
[D7,D6,D5,D4,D3,D2,D1,D0].</p>
<p>To sum up the message consists of two 8-bit transfers:</p>
<pre class="plain"><code>1) [A/B, --, GA, SHDN, D7, D6, D5, D4]
2) [D3, D2, D1, D0, X, X, X, X]</code></pre>
<p>In C code, the two transfers are constructed as follows</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>u8 tx0 <span class="op">=</span> <span class="op">(</span>config <span class="op">&lt;&lt;</span> <span class="dv">4</span><span class="op">)</span> <span class="op">|</span> d_high<span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>u8 tx1 <span class="op">=</span> d_low <span class="op">&lt;&lt;</span> <span class="dv">4</span><span class="op">;</span></span></code></pre></div>
<p>Since <code>D</code> is 8-bit, if the multiplier is “times 1”
(<code>GA=1</code>), i.e. <code>VOUT=D/2</code>, then the largest value
we can output is</p>
<pre class="plain"><code>0x7F8 = (0xFF &lt;&lt; 4) &gt;&gt; 1 = 0xFF &lt;&lt; 3 = 2040 mV</code></pre>
<p>If the multiplier is “times 2” (<code>GA=0</code>),
i.e. <code>VOUT=D</code>, then the largest value is</p>
<pre class="plain"><code>0xFF0 = 0xFF &lt;&lt; 4 = 4080 mV</code></pre>
<p>On the RPi, the output is limited to 3300mV though. We also see that
the resolution in x1 mode is 8, while the resolution in x2 mode is 16.
So we could as well say that in x1 mode the maximum voltage is 2047, and
4095 in x2 mode.</p>
<p>Finally, the two output registers are updated when LDAC goes low.
That’s why we do:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>gpio_set_value<span class="op">(</span>ldac_gpio<span class="op">.</span>gpio_nr<span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// LDAC low</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>gpio_set_value<span class="op">(</span>ldac_gpio<span class="op">.</span>gpio_nr<span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// LDAC high</span></span></code></pre></div>
<p>The <code>write</code> callback is shown below:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ssize_t</span> mcp4802_write<span class="op">(</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> file <span class="op">*</span>filep<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> __user <span class="op">*</span>buf<span class="op">,</span> <span class="dt">size_t</span> count<span class="op">,</span> loff_t <span class="op">*</span>offset<span class="op">)</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> spi_transfer t<span class="op">[</span><span class="dv">2</span><span class="op">];</span> <span class="co">// Three transfers of 8-bit each = 2 x 12 bits</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> spi_message m<span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> len<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> n_not_copied<span class="op">;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> kbuf<span class="op">[</span>BUFLEN<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">};</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret<span class="op">,</span> value<span class="op">;</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    len <span class="op">=</span> count <span class="op">&lt;</span> BUFLEN <span class="op">?</span> count <span class="op">:</span> BUFLEN <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// kbuf must be null-terminated</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    n_not_copied <span class="op">=</span> copy_from_user<span class="op">(</span>kbuf<span class="op">,</span> buf<span class="op">,</span> len<span class="op">);</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span>ret <span class="op">=</span> kstrtoint<span class="op">(</span>kbuf<span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="op">&amp;</span>value<span class="op">))</span> <span class="op">==</span> <span class="op">-</span>ERANGE<span class="op">)</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>        ERRGOTO<span class="op">(</span>write_exit<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\t</span><span class="st">overflow</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>ret <span class="op">==</span> <span class="op">-</span>EINVAL<span class="op">)</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>        ERRGOTO<span class="op">(</span>write_exit<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\t</span><span class="st">invalid value</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>t<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>t<span class="op">));</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    spi_message_init<span class="op">(&amp;</span>m<span class="op">);</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minor <span class="op">=</span> MINOR<span class="op">(</span>filep<span class="op">-&gt;</span>f_inode<span class="op">-&gt;</span>i_rdev<span class="op">);</span> <span class="co">// Could use iminor instead.</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span>spi <span class="op">=</span> dac<span class="op">[</span>minor<span class="op">].</span>spi<span class="op">;</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> value <span class="op">&gt;</span> <span class="bn">0xFFF</span><span class="op">)</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>        ERRGOTO<span class="op">(</span>write_exit<span class="op">,</span> <span class="st">&quot;value </span><span class="sc">%i</span><span class="st"> is out of range. Must be in [0, </span><span class="sc">%i</span><span class="st">].</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>                value<span class="op">,</span> <span class="bn">0xFFF</span><span class="op">);</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> gainX2 <span class="op">=</span> value <span class="op">&gt;</span> <span class="bn">0x7FF</span><span class="op">;</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>    u8 d <span class="op">=</span> <span class="op">(</span>gainX2 <span class="op">?</span> <span class="op">(</span>value <span class="op">&gt;&gt;</span> <span class="dv">4</span><span class="op">)</span> <span class="op">:</span> <span class="op">(</span>value <span class="op">&gt;&gt;</span> <span class="dv">3</span><span class="op">))</span> <span class="op">&amp;</span> <span class="bn">0xFF</span><span class="op">;</span></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>    u8 d_high <span class="op">=</span> <span class="op">(</span>d <span class="op">&gt;&gt;</span> <span class="dv">4</span><span class="op">)</span> <span class="op">&amp;</span> <span class="bn">0x0F</span><span class="op">;</span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>    u8 d_low <span class="op">=</span> d <span class="op">&amp;</span> <span class="bn">0x0F</span><span class="op">;</span></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>    u8 config <span class="op">=</span> <span class="op">(</span>dac<span class="op">[</span>minor<span class="op">].</span>channel <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>                    <span class="op">?</span> SHDN       <span class="co">// DAC_A, active mode</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>                    <span class="op">:</span> AB <span class="op">|</span> SHDN<span class="op">;</span> <span class="co">// DAC_B, active mode</span></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>    config <span class="op">|=</span> gainX2 <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> GA<span class="op">;</span> <span class="co">// Conf. bit nr. 1 is set if X1, unset if X2</span></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>    u8 tx0 <span class="op">=</span> <span class="op">(</span>config <span class="op">&lt;&lt;</span> <span class="dv">4</span><span class="op">)</span> <span class="op">|</span> d_high<span class="op">;</span></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>    u8 tx1 <span class="op">=</span> d_low <span class="op">&lt;&lt;</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">0</span><span class="op">].</span>tx_buf <span class="op">=</span> <span class="op">&amp;</span>tx0<span class="op">;</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">0</span><span class="op">].</span>rx_buf <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">0</span><span class="op">].</span>len <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>    spi_message_add_tail<span class="op">(&amp;</span>t<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">1</span><span class="op">].</span>tx_buf <span class="op">=</span> <span class="op">&amp;</span>tx1<span class="op">;</span></span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">1</span><span class="op">].</span>rx_buf <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span><span class="dv">1</span><span class="op">].</span>len <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>    spi_message_add_tail<span class="op">(&amp;</span>t<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a>    gpio_set_value<span class="op">(</span>ldac_gpio<span class="op">.</span>gpio_nr<span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// LDAC high</span></span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-56"><a href="#cb32-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> err <span class="op">=</span> spi_sync<span class="op">(</span>m<span class="op">.</span>spi<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb32-57"><a href="#cb32-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>err <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb32-58"><a href="#cb32-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb32-59"><a href="#cb32-59" aria-hidden="true" tabindex="-1"></a>        pr_err<span class="op">(</span><span class="st">&quot;spi_sync: FAIL&quot;</span><span class="op">);</span></span>
<span id="cb32-60"><a href="#cb32-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err<span class="op">;</span></span>
<span id="cb32-61"><a href="#cb32-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-62"><a href="#cb32-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-63"><a href="#cb32-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Update two output registers using the Latch.</span></span>
<span id="cb32-64"><a href="#cb32-64" aria-hidden="true" tabindex="-1"></a>    gpio_set_value<span class="op">(</span>ldac_gpio<span class="op">.</span>gpio_nr<span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// LDAC low</span></span>
<span id="cb32-65"><a href="#cb32-65" aria-hidden="true" tabindex="-1"></a>    gpio_set_value<span class="op">(</span>ldac_gpio<span class="op">.</span>gpio_nr<span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// LDAC high</span></span>
<span id="cb32-66"><a href="#cb32-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-67"><a href="#cb32-67" aria-hidden="true" tabindex="-1"></a>write_exit<span class="op">:</span></span>
<span id="cb32-68"><a href="#cb32-68" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">+=</span> count<span class="op">;</span></span>
<span id="cb32-69"><a href="#cb32-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb32-70"><a href="#cb32-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 data-number="3.4" id="testing-the-mcp4802-driver"><span
class="header-section-number">3.4</span> Testing the MCP4802 driver</h2>
<h3 data-number="3.4.1" id="scope-screenshot"><span
class="header-section-number">3.4.1</span> Scope screenshot</h3>
<p><img src="images/mcp4802_scope_adc0_adc1.png" /></p>
<h3 data-number="3.4.2" id="logic-screenshot-for-the-mcp4802"><span
class="header-section-number">3.4.2</span> Logic screenshot for the
MCP4802</h3>
<p>The desired voltage is 3V. Two transfers
<code>0x9B=0b1001'1011</code> and <code>0xB0=0b1011'0000</code> from
which we can deduce that the configuration is <code>A/B=1</code> (write
to <code>/dev/dac1</code>), <code>GA=0</code> (x2 mode since the desired
value 3000mv is greater than 2047mV, the maximum value in x1 mode),
<code>SHDN=1</code> (output activated). The data byte is the low nibble
of the first transfer concatenated with the high nibble of the second
transfer i.e <code>D=0xBB=187</code>. This value is shifted left by 4
and divided by 2 (because <code>GA=0</code>) so the actual value is
<code>D &lt;&lt; 4 = 2992</code>. The measured voltage is 2.992V which
is the largest multiple of 16 (the resolution when x2) smaller than the
desired voltage of 3V.</p>
<p><img src="images/mcp4802_CH1_logic_3000mv.png" /></p>
<p>If we instead desire a voltage of 2V on channel 0, then we get the
same configuration as above but this time with <code>A/B=0</code> (write
to <code>/dev/dac0</code>), <code>GA=1</code> (x1 since desired value is
smaller than 2047mV). As expected the configuration nibble is
<code>0X3=0b0011</code> corresponding to <code>A/B=0</code> (write to
<code>/dev/dac0</code>), <code>GA=1</code> (x1), <code>SHDN=1</code>
(output activated). The received value is <code>D=0xFA=250</code>, and
so the actual value is <code>250&lt;&lt;3 = 2000</code>. We hit the
desired voltage of 2V, which was to be expected since 2000 is a multiple
of 8 (the resolution in x1 mode).</p>
<p><img src="images/mcp4802_CH0_logic_2000mv.png" /></p>
<h1 data-number="4" id="mcp3202-and-mcp4802-working-together."><span
class="header-section-number">4</span> MCP3202 and MCP4802 working
together.</h1>
<p>The ultimate test. Connect the OUT line to the IN lines and see the
analogue signal be converted to a digital value and then back to an
analogue signal by connection the ADC and DAC devices using their
respective AIN and AOUT lines. It works!</p>
</body>
</html>
